[{"title":"QT Creator入门","date":"2021-01-17T07:00:05.000Z","path":"2021/01/17/QT-Creator/","text":"VSCode配置QT 是的，VSCode也能写QT。VSCode yyds!!! 首先，在QT Creator中创建新项目。build工具选择CMake。 将QT的bin目录添加到系统环境变量。如我的为E:\\qt\\5.13.2\\msvc2017_64\\bin。这个要根据个人的版本等选择。 在VSCode中下载CMake, CMake Tools插件。(如果之前没有配置过C++环境，则还要下载C/C++支持) 打开刚刚创建的工程目录。F7选择工具包，同样要根据创建QT Project时的设置选择。 Ctrl + F5以非调试模式运行。此时已经可以正常运行。 但ui文件的包含还有一些小问题。 在CMakeLists.txt最后一行添加下列语句，问题解决。(注意，qtest是刚刚建立的项目的名称，需要自己手动修改) 1target_include_directories(qtest PRIVATE &quot;$&#123;CMAKE_BINARY_DIR&#125;/qtest_autogen/include_Debug&quot;) 具体原理，暂时还不懂。 参考：使用VS Code进行Qt开发的实现 QT继承关系图源：https://www.processon.com/view/5758f23de4b080e40c7feaca QPushButton 12345678910111213141516171819//创建一个QPushButton对象：QPushButton *btn = new QPushButton;//设置button的文本：btn-&gt;setText(const QString&amp;);//设置button的父对象：(如在某对象的构造函数中，要将button的父对象设置为该对象，则填入this)btn-&gt;setParent(const QObject*&amp;);//在构造函数中完成以上初始化：QPushButton *btn2 = new QPushButton(&quot;text&quot;, this);//移动：move(const QPoint&amp;);//存在由两个数向QPoint隐式转换的构造函数//重设大小：resize(const QSize&amp;);//or:resize(int w, int h);","categories":[{"name":"Cpp","slug":"Cpp","permalink":"http://endsieg77.github.io/categories/Cpp/"},{"name":"QT","slug":"Cpp/QT","permalink":"http://endsieg77.github.io/categories/Cpp/QT/"}],"tags":[{"name":"utilities","slug":"utilities","permalink":"http://endsieg77.github.io/tags/utilities/"}]},{"title":"Python汉语抽象化企划","date":"2021-01-15T06:13:14.000Z","path":"2021/01/15/Python汉语抽象化企划/","text":"事情的起因是某晚我和群友的口嗨。“如果用Python写一个脚本可以自动把汉语转化成抽象字，那会不会很有意思呢？”于是便有了现在的这个企划。 现有的轮子？来几个罢。 想到点子的我立马上网去查了查Python是否有相关的库可以直接拿来用。果然Python没让我失望，我立马搜索到了PyPinyin库。“只要能把拼音索引到抽象符号，事情就变得简单了呢。” 说简单但其实也并不简单 脚本的基本思路确实简单。将汉字转化成拼音，用字典索引到列表，从列表中随机抽取抽象符号，替换拼音，得到文字即可。但我并没有找到现成的成熟的抽象话字典。 但网络上确实有现成的轮子：抽象话生成器。 同时，我发现它并不完善。 太好了！可以为我所用。 坑先开在这，有生之年慢慢填。","categories":[{"name":"Python","slug":"Python","permalink":"http://endsieg77.github.io/categories/Python/"},{"name":"Project","slug":"Python/Project","permalink":"http://endsieg77.github.io/categories/Python/Project/"}],"tags":[{"name":"PyPinyin","slug":"PyPinyin","permalink":"http://endsieg77.github.io/tags/PyPinyin/"},{"name":"emoji","slug":"emoji","permalink":"http://endsieg77.github.io/tags/emoji/"}]},{"title":"Highway to Python","date":"2021-01-12T12:37:11.000Z","path":"2021/01/12/Python-Preview/","text":"Overture Brief Introduction Python是一种动态的(变量类型, 函数定义可以在代码中改变)、强类型的(不同类型之间的运算有严格的限制)脚本语言(也叫胶水语言)(用来拼接一个项目中不同语言的成分)。 其由荷兰数学和计算机科学研究学会的Guido van Rossum 于1990 年代初设计。名字来源为英国20世纪70年代首播的电视喜剧《蒙提·派森的飞行马戏团》(Monty Python’s Flying Circus)。Python 2和Python 3有很大区别，现在Python 2已经停止更新。我们一般情况下介绍的都是Python 3。 Python涵盖了许多有用的库，可以用于数学计算、数据可视化、机器学习、信息安全等各个领域。 Python如今在广大非计算机专业也是一门常见的入门语言。 在Python中， Indent(缩进)是一个非常重要的概念。Python程序员应该养成良好的缩进习惯。 Python Zen在Python Shell里输入import this 终端会给出如下的输出： 1234567891011121314151617181920The Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren&#x27;t special enough to break the rules.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you&#x27;re Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it&#x27;s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let&#x27;s do more of those! 算是个小彩蛋。Coding是浪漫的，不是吗？ Insert User Snippets in vscode文件-&gt;首选项-&gt;用户片段 向对话框中输入python， 在跳出的python.json文件里加入下列片段 1234567891011121314&#123; &quot;Print to console&quot;: &#123; &quot;prefix&quot;: &quot;main&quot;, //用户片段名 &quot;body&quot;: [ &quot;def main():&quot;, &quot; $0&quot;, //光标起始位置 &quot;&quot;, //空行 &quot;if __name__ == \\&quot;__main__\\&quot;:&quot;, &quot; main()&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Log output to console&quot; &#125;&#125; 保存。 然后在后缀为py的文件中键入main，按tab(或手动/enter也行)，便会自动跳出： 12345def main():if __name__ == &quot;__main__&quot;: main() 你可以往用户片段中加入各种实用的片段，大大提高编程的效率。 其他语言的配置方法都是类似的。这里不多赘述。 Python Syntaxes &amp; Syntatic Sugar Identifier &amp; condition statement 在Python中，变量名可以是中文。 a &lt;= x &lt;= b 这样的条件语句，在Python中可以得到C中a &lt;= x &amp;&amp; b &gt;= x的效果 Python中的逻辑运算相关的关键字: and, or, true, false 注意: Python中不存在自带的switch语句. Python的三目运算符x if condition else y: 若condition成立，返回x，否则y。 实例详见string process - 一道简单的OJ题 string process 字符串切片 s[index]: 首字符从0开始计，返回第index位的字符。若index为负，则以最后一个字符为-1，以此类推。 s[pos_1 = 0: pos_2 = -1]: 从pos_1开始，到pos_2前一位结束，0和-1为缺省值。s[:]代表整个字符串。 s[pos_1 = 0: pos_2 = -1: pace = 1]: pace为步长。每隔pace截取一个字符。若pace为负值，则得到的结果是将s逆向，以终止位置开始，起始位置结束，取pace的绝对值所得到的结果。s[::-1]得到逆向的字符串。 find()查找子串在原串中的位置，若没有，返回-1。 strip()去除字符串两边的空格。 lower(), upper()字面意思，大小写转换。 split(), join() 123456789101112131415161718192021222324# 一行高精度# split()将输入按某字符分割，缺省为空格，读到\\n结束，返回一个列表# map(_Pred, _Iterable)将_Pred函数作用于_Iterable，结果是一个map对象# list()将map转为list# sum()取得list的数值和print(sum(list(map(int, input().split()))))# _Pred部分也可以填入lambda表达式# 例如:print(sum(list(map(lambda x: int(x), input().split()))))# 与上面等效# 和map()形式类似的函数还有reduce()和filter()# reduce()将两参函数作用于列表的前两个元素，再将前两个元素的结果作用于第三个函数，如是往复# filter()则是筛子# join()是split()的逆方法。seq = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]print(&#x27;4&#x27;.join(seq))# 输出: 14243# lambdalambda [params]: expr# 比其他语言的lambda要简洁许多 三引号允许定义多行字符串。如： 12345s = &#x27;&#x27;&#x27;CSSisAwesome.&#x27;&#x27;&#x27; 打印s，将会保留原格式。 RegExp 12345678910111213# 导入re模块import re# match()函数re.match(pattern, string, flags=0)# pattern为正则式，string为要匹配的字符串，flags为匹配模式# 匹配模式：# re.I 匹配对大小写不敏感# re.L 本地化识别# re.M 多行匹配，影响^和$# re.S 使`.`匹配换行之外所有字符# re.U 根据unicode集解析字符，影响\\w, \\W, \\b, \\B# re.X 可以用更灵活的格式让你的正则式更容易理解# 详见：https://www.runoob.com/python/python-reg-expressions.html#flags group(), groups() 方法我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 12345678910111213141516import rea = &quot;123abc456&quot;pattern = &quot;([0-9]*)([a-z]*)([0-9]*)&quot;# 直观地看，每个括号代表一个分组，group()缺省为0# 123abc456,返回整体print(re.search(pattern,a).group(0))# 123print(re.search(&quot;([0-9]*)([a-z]*)([0-9]*)&quot;,a).group(1))#abcprint(re.search(&quot;([0-9]*)([a-z]*)([0-9]*)&quot;,a).group(2))#456print(re.search(&quot;([0-9]*)([a-z]*)([0-9]*)&quot;,a).group(3))# (&#x27;123&#x27;, &#x27;abc&#x27;, &#x27;456&#x27;)print(re.search(&quot;([0-9]*)([a-z]*)([0-9]*)&quot;,a).groups()) 另一个实例： 123456789101112import reline = &quot;Cats are smarter than dogs&quot;matchObj = re.match( r&#x27;(.*) are (.*?) .*&#x27;, line, re.M|re.I)if matchObj: print(&quot;matchObj.group() : &quot;, matchObj.group()) print(&quot;matchObj.group(1) : &quot;, matchObj.group(1)) print(&quot;matchObj.group(2) : &quot;, matchObj.group(2))else: print(&quot;No match!!&quot;) 结果： matchObj.group() : Cats are smarter than dogsmatchObj.group(1) : CatsmatchObj.group(2) : smarter start(), end(), span() 方法start() 返回匹配字符串的起始位置； end() 返回终止位置； span() 返回一个元组，分别为起始和终止位置。 一道简单OJ题实战输入格式：”三个字母一个数字”，字母可能是”USD”或”RMB”。输出USD和RMB互换的结果。 输出格式”三个字母一个数字”，数字保留到小数点后两位。 USD和RMB汇率6.78。 两种写法: (本题中所涉及的格式化输出请见本文以下的格式化输出章节。) 12345678# 用正则表达式，仅仅为了熟悉Python的正则import rea = re.search(r&quot;([a-z]+)([\\d]+)&quot;, input(), flags=re.I).groups()print(f&quot;RMB&#123;float(a[1])*6.78:.2f&#125;&quot; if a[0] == &#x27;USD&#x27; else f&quot;USD&#123;float(a[1])/6.78:.2f&#125;&quot;)# 两行搞定s = input()print(f&quot;RMB&#123;float(s[3:])*6.78:.2f&#125;&quot; if s[:3] == &#x27;USD&#x27; else f&quot;USD&#123;float(s[3:])/6.78:.2f&#125;&quot;) x for x in... if...语句 12345# 这种写法非常简洁美观# 筛选list中3的整倍数foo = [18, 9, 17, 5, 8]print([x for x in foo if x%3==0])# 类似C++的range-based for 输出： [18, 9] Overload in Python Python中不存在原生支持严格意义的函数重载，对函数的每一次重定义都将会覆盖上一个函数。参数类型不同的函数重载只能用逻辑判断来实现。 pass 什么也不做。用作占位语句。等价于C语言的;。 Python generator &amp; iterable 带有yield的函数在Python中为generator(生成器)。generator在python中生成一个可迭代(iterable)的对象。 对可迭代对象可以进行range-based for (类定义了__iter__()方法)，和__getitem__()(不必要)。 常见的可迭代对象：(1) list、tuple、dict、set、str; (2) generator; 判断对象是否可迭代：isinstance(e, collections.Iterable) 链接： yield菜鸟教程 深入理解可迭代 class &amp; OOPPython的一个基本的类定义如下: 1234567class className(): # attributes block def __init__(params): # init body, 如果不需要，可以填入pass #Other Methods 类的attribute利用.运算符访问。类似C的结构体。 Snippet: 123456789101112131415161718192021222324252627282930313233def main(): # class definition: class P: # public: name = &quot;&quot; # protected: _age = 0 # private: __gender = &quot;Female&quot; # constructor with default params def __init__(self, name, gender=&quot;Female&quot;, age=10): self.name = name self.__gender = gender self._age = age # method def selfIntro(self): print(&quot;My name is %s, age is %d and I am %s&quot; % \\ (self.name, self._age, self.__gender)) p1 = P(&quot;LG&quot;) p2 = P(&quot;ZG&quot;, &quot;Female&quot;, 5) p3 = P(gender=&quot;Male&quot;, name=&quot;XQ&quot;, age=15) p1.selfIntro() p1.__gender = &quot;Male&quot; p1.selfIntro() p1._age = 20 p1.selfIntro() p2.selfIntro() p3.selfIntro()if __name__ == &quot;__main__&quot;: main() 同时我们发现： p1调用自我介绍函数的时候的三次输出分别为: 123My name is LG, age is 10 and I am FemaleMy name is LG, age is 10 and I am FemaleMy name is LG, age is 20 and I am Female 可以看出，对private类型成员变量修改后不会改变变量的值，也不会有报错信息。 对public类型成员变量修改后确确实实发生了改变。(原因未知) 格式化输出在上文片段中，如果将: 123# C风格格式化输出print(&quot;My name is %s, age is %d and I am %s&quot; % \\ (self.name, self._age, self.__gender)) 替换为: 1print(f&quot;My name is &#123;self.name&#125;, age is &#123;self._age&#125; and I am &#123;self.__gender&#125;&quot;) 效果是一样的。Python的格式化输出功能要比原生C, C++要完善不少。 Python中还可以对字符串类型调用format()方法来达到格式化输出的效果。 global Python中若要使函数体内对变量的改变作用于函数体外，可以在变量前加上global关键字。 zip() 123456def zip(iter1: Iterable[_T1])zip(*iterables) --&gt; A zip object yielding tuples until an input is exhausted. list(zip(&#x27;abcdefg&#x27;, range(3), range(4))) [(&#x27;a&#x27;, 0, 0), (&#x27;b&#x27;, 1, 1), (&#x27;c&#x27;, 2, 2)] The zip object yields n-length tuples, where n is the number of iterables passed as positional arguments to zip(). The i-th element in every tuple comes from the i-th iterable argument to zip(). This continues until the shortest argument is exhausted. eval()将字符串作为一个Python表达式执行。和Php的eval()类似。 1234a = 1b = 2c = eval(&quot;a if a &gt; b else b&quot;)print(c) 输出：2 Container tuple不可变的序列。 注意：单值元组在定义时要在元素后加一个,，如tp = (12,)，防止语义冲突。 tuple的连接 类似tp3 = tp1 + tp2 tuple的删除 del tp more details see: python中del的用法 elem in tp 判断某元素是否在tuple中，返回布尔值。 切片 参见string process一节。规则是类似的。 tuple的相关函数 min(tp), max(tp), len(tp), tuple(seq) 字面意思，很好理解。 tuple是最基本的序列，对tuple可以做的所有操作几乎都可以用在其他序列中。故下文将尽量避免冗余。 list可以增删查改的序列。用[]定义。 list可以用+连接，同样，可以用del删除某一元素。也可以运用in，find()等。 方法 作用 append(obj) 向列表最后添加一个元素。 count(obj) 返回obj在列表中出现的次数。 extend(seq) 将seq追加到原列表中。 index(obj) 获取第一个出现的obj的索引。如要获取最后一个，len(list) - list[::-1].index(obj) - 1是一种方法。 insert(index, obj) 将obj插入列表索引index的位置。 pop(index = -1) 删除列表一个元素。默认索引-1。即删除最后一个。并返回该元素的值。 remove(obj) 移除列表中第一个obj。 reverse() 列表反向。 sort(key = None, reverse = False) 排序。key为函数，指定用元素的哪一项进行比较。可以为lambda函数。reverse = False代表升序。sort的原型：sort(*, key: Optional[Callable[[_T], Any]]=…, reverse: bool=…) -&gt; None set, dict 没什么好说的，跳过了。 more details see: Python dict Python set Inside Python Mechanism One 123456789101112131415c = &#123;&#125;def foo(): f = dict(zip(list(&quot;abcd&quot;), [1, 2, 3, 4])) c.update(f)def main(): a = b = c foo() a[&#x27;e&#x27;] = 5 b[&#x27;f&#x27;] = 6 print(f&quot;&#123;a&#125;\\n&#123;b&#125;\\n&#123;c&#125;&quot;)if __name__ == &quot;__main__&quot;: main() 输出： 123&#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4, &#39;e&#39;: 5, &#39;f&#39;: 6&#125;&#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4, &#39;e&#39;: 5, &#39;f&#39;: 6&#125;&#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4, &#39;e&#39;: 5, &#39;f&#39;: 6&#125; 深入理解Python变量赋值问题 Python与对象 mutable &amp; immutable objectpython中的变量间赋值本质上为传引用。而用字面值对变量赋值，根据对象的不同，会产生不同的行为。 我们依据这一性质将对象分为两类： 不可变。常见的不可变对象为int, float, str, complex, tuple; 可变。常见的可变对象为list和dict. 我们将从下面的代码理解Python的这一特性。 12345678def main(): a = b = 10 print(f&quot;addr of a is: &#123;id(a)&#125;, b is: &#123;id(b)&#125;&quot;) b = 5 print(f&quot;addr of a is: &#123;id(a)&#125;, b is: &#123;id(b)&#125;&quot;)if __name__ == &quot;__main__&quot;: main() 两次的输出结果: addr of a is: 2347657685584, b is: 2347657685584addr of a is: 2347657685584, b is: 2347657685424 可见，Python对不可变对象的字面值赋值处理方式是： 开辟一块新的内存，让被改变的对象指向这块内存。其他的对象的内存指向不改变。 而对于可变对象，处理的方式便不同了。 对可变对象的修改不会开辟新的内存空间。但也有特例，如果赋予可变对象一个不可变对象字面值，那么可变对象的仍会开辟新的内存地址。 下面给出一个规律性的总结： 当对一个变量赋值的时候， 如果右式是变量，那么左式得到右式的引用(reference)； 如果右式是不可变对象字面值，那么左式开辟新的内存空间用来存储，并指向这块新的内存空间； 如果右式是可变对象字面值，则在原地址基础上对存储数据进行修改。 编写一个不可变的类 123456789101112131415161718# 这里直接拷贝上述博文的代码class It(object): __slots__ = [&#x27;vals&#x27;] def __init__(self, vals): super().__setattr__(&#x27;vals&#x27;,vals) # super()返回父类对象, 调用父类的 # __setattr__()方法，用&#x27;vals&#x27;来初始化自身。 def __setattr__(self, key, value): raise AttributeError(&#x27;不可变类&#x27;) # 禁用本类的__setattr__()方法 def __eq__(self, other): # return id(self) == id(other) return self.vals == other.vals def __hash__(self): # return 1 # return random.randint(0,100) return hash(&#x27;;&#x27;.join(self.vals)) # return hash(id(self)) 可变与可哈希Python中，可变对象是不可哈希的，而不可变对象是可哈希的。 体现在字典上：{keys: vals} 键值对的键必须是不可变对象，因为不可变对象可以产生哈希值，而Python的字典底层是用哈希表实现的。(C++中的std::map底层则是红黑树，而std::unordered_map底层是哈希表)。 而对于值则没有要求。 不可变对象的哈希值通过调用__hash__()方法来获得，故用户自定义的不可变类必须给出合理的哈希函数重写。","categories":[{"name":"Python","slug":"Python","permalink":"http://endsieg77.github.io/categories/Python/"}],"tags":[{"name":"grammatical","slug":"grammatical","permalink":"http://endsieg77.github.io/tags/grammatical/"},{"name":"basic","slug":"basic","permalink":"http://endsieg77.github.io/tags/basic/"}]},{"title":"todos in winter vacation","date":"2021-01-12T08:48:15.000Z","path":"2021/01/12/todos-in-winter-vacation/","text":"时间 安排 8:00 最晚起床时间 8:30-9:00 背单词 9:10-11:10 数学 11:10 点外卖 11:10-12:00 数学 12:00-12:30 午饭 12:30-14:00 午休 14:00-15:00 Python 15:10-16:30 大物 16:40-17:10 英语听力 17:10-19:00 自由安排学习吃饭 19:00-20:00 锻炼 20:00-21:00 看书 以后 娱乐 最晚24:00 睡觉","categories":[{"name":"study","slug":"study","permalink":"http://endsieg77.github.io/categories/study/"}],"tags":[{"name":"todos","slug":"todos","permalink":"http://endsieg77.github.io/tags/todos/"}]},{"title":"Centos Cpp17 Config","date":"2021-01-12T06:08:53.000Z","path":"2021/01/12/Centos-Cpp17-Config/","text":"gcc: error: unrecognized command line option ‘-std=c++17’解决方案：升级g++, gcc 输入以下命令: 1234567891011121314151617181920212223cd /usr/local/src# 下载gcc5.2.0源码wget http://ftp.gnu.org/gnu/gcc/gcc-5.2.0/gcc-5.2.0.tar.bz2tar -jxvf gcc-5.2.0.tar.bz2# 进入gcc目录安装cd gcc-5.2.0# 下载某些依赖包./contrib/download_prerequisites# 创建bulid文件夹mkdir buildcd build../configure --prefix=/usr/local/gcc --enable-languages=c,c++ --disable-multilib# 编译安装,此过程耗时较长make &amp;&amp; make install# 修改软连接mv /usr/bin/gcc /usr/bin/gcc_bakln -s /usr/local/gcc/bin/gcc /usr/bin/gccmv /usr/bin/g++ /usr/bin/g++_bakln -s /usr/local/gcc/bin/g++ /usr/bin/g++# 查看升级后版本gcc --versong++ --version#参考: https://blog.csdn.net/qq_42189083/article/details/109612289 后续问题：’GLIBCXX_3.4.21’ not found 参考: https://itbilu.com/linux/management/NymXRUieg.html 检查动态库1strings /usr/lib64/libstdc++.so.6 | grep GLIBC 输出结果: 12345678910111213141516GLIBCXX_3.4GLIBCXX_3.4.1GLIBCXX_3.4.2GLIBCXX_3.4.3GLIBCXX_3.4.4GLIBCXX_3.4.5GLIBCXX_3.4.6GLIBCXX_3.4.7GLIBCXX_3.4.8GLIBCXX_3.4.9GLIBCXX_3.4.10GLIBCXX_3.4.11GLIBCXX_3.4.12GLIBCXX_3.4.13GLIBCXX_FORCE_NEWGLIBCXX_DEBUG_MESSAGE_LENGTH 可见，动态库并没有随着g++, gcc的更新而更新 查询动态库的位置12# 先切换为root用户find / -name &quot;libstdc++.so*&quot; 结果： 1234/home/gcc-5.2.0/gcc-temp/stage1-x86_64-unknown-linux-gnu/libstdc++-v3/src/.libs/libstdc++.so/home/gcc-5.2.0/gcc-temp/stage1-x86_64-unknown-linux-gnu/libstdc++-v3/src/.libs/libstdc++.so.6/home/gcc-5.2.0/gcc-temp/stage1-x86_64-unknown-linux-gnu/libstdc++-v3/src/.libs/libstdc++.so.6.0.21…… 注意：上述结果根据不同安装设置可能会有差异。 复制后，修改系统默认动态库的指向，即：重建默认库的软连接。 切换工作目录至/usr/lib64： 1cd /usr/lib64 删除原来软连接： 1rm -rf libstdc++.so.6 将默认库的软连接指向最新动态库： 1ln -s libstdc++.so.6.0.21 libstdc++.so.6 默认动态库升级完成。重新运行以下命令检查动态库： 1strings /usr/lib64/libstdc++.so.6 | grep GLIBC 现在输出如下： 123456789101112131415161718192021222324252627GLIBCXX_3.4GLIBCXX_3.4.1GLIBCXX_3.4.2GLIBCXX_3.4.3GLIBCXX_3.4.4GLIBCXX_3.4.5GLIBCXX_3.4.6GLIBCXX_3.4.7GLIBCXX_3.4.8GLIBCXX_3.4.9GLIBCXX_3.4.10GLIBCXX_3.4.11GLIBCXX_3.4.12GLIBCXX_3.4.13GLIBCXX_3.4.14GLIBCXX_3.4.15GLIBCXX_3.4.16GLIBCXX_3.4.17GLIBCXX_3.4.18GLIBCXX_3.4.19GLIBCXX_3.4.20GLIBCXX_3.4.21GLIBC_2.3GLIBC_2.2.5GLIBC_2.3.2GLIBCXX_FORCE_NEWGLIBCXX_DEBUG_MESSAGE_LENGTH","categories":[{"name":"Centos7","slug":"Centos7","permalink":"http://endsieg77.github.io/categories/Centos7/"},{"name":"Linux","slug":"Centos7/Linux","permalink":"http://endsieg77.github.io/categories/Centos7/Linux/"}],"tags":[{"name":"utilities","slug":"utilities","permalink":"http://endsieg77.github.io/tags/utilities/"},{"name":"remedies","slug":"remedies","permalink":"http://endsieg77.github.io/tags/remedies/"}]},{"title":"Cantor Expansion","date":"2021-01-08T14:21:57.000Z","path":"2021/01/08/Cantor-Expansion/","text":"9位康托展开代码：1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int factorial[] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;;int a[10];int CantorExpansion(int *stat) &#123; int index = 0, counted; for(int i = 0; i &lt; 9; ++i) &#123; counted=0; for(int j = i + 1; j &lt; 9; ++j) if(stat[j] &lt; stat[i]) ++counted; index += counted * factorial[8 - i]; &#125; return index;&#125;int main(int argc, char *argv[]) &#123; for(int i = 0; i &lt; 9; ++i) cin &gt;&gt; a[i]; cout &lt;&lt; CantorExpansion(a) &lt;&lt; endl; return 0;&#125; 康托展开从一个不重复序列中得到某个排列在全排列中的字典序。 以9位(01235678)为例： State 012345678 012345687 012345768 … 876543210 Cantor Value 0 1 2 … 362880 原理: 从第一位开始，寻找往后序列中比第一位小的数，将其放在首位，剩下的数全排列 固定第一位，寻找往后序列比第二位小的数，将其放在第二位，剩下的数全排列 往后按此规律即可，直到遍历到最后一位则返回值: X = a_n\\cdot(n-1)!+a_{n-1}\\cdot(n-2)!+a_{n-2}\\cdot(n-3)!+...+a_i\\cdot(i-1)!+...+a_1\\cdot0!,\\\\ 其中0\\le{a_i}\\le{9}(1","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://endsieg77.github.io/categories/algorithm/"}],"tags":[{"name":"realization","slug":"realization","permalink":"http://endsieg77.github.io/tags/realization/"}]},{"title":"WATERLOO 2021-1-8","date":"2021-01-08T12:34:42.000Z","path":"2021/01/08/WATERLOO-2021-1-8/","text":"​ Thanks to my teacher of Advanced Algebra. I wouldn’t know what a mess I had made without her hint, but I would mistake the seek of sense of belonging for my only aim. ​ Shall I be one sage that obeys the virtue of being silent? I used to think it boring and colorless, but now, I must consider the problem once again. ​ 先来想一想你是谁吧？你是一个数学专业的学生，但你在数学方面却毫不上心。数学是你在填报志愿的时候填报的第四位，这条路也算是你自己选择的。其次，你身处在一个弱校，校内的教学进度不快，学校管的不严，学业压力不大，在这样的情况下，你却并没有积极寻求更多的专业知识。你最爱干的事情是什么呢？对着一堆没用的代码在那边意淫，或者整鼓一些完全不紧急的事情。 ​ 请你好好想一想，你这半年打了多少游戏，荒废了多少时间？请你好好想一想，你对得起你自己吗？你是觉得编程一点都用不到数学是吗？你想一辈子敲业务逻辑是吗？你想放弃思考，或者放弃自己长时间培养的思考的习惯是吗？你对得起信任你的那些人吗？你有脸去见沈老师吗？你好好学习，努力生活了吗？为什么总是去想那些不切实际的事情呢。为什么老是做一些不切实际的梦呢？ ​ 你是觉得数学很轻松吗？你是把那些醉生梦死的人当作自己的对手吗？你觉得自己很聪明吗？你觉得自己一点都不需要练习吗？你凭什么上课不听呢？你凭什么躺在床上颓废呢？公式都记不住，我真是呵呵了。就你这吊样，就你这吊成绩，转到计科去就能好了？计科人是不用学数学咯？人家高数进度比你快，考的比你难，人家脑子比你聪明。更何况照这样下去，你的成绩到底够不够转专业都难说呢！ ​ 我喜欢你努力追求喜欢的东西的样子，但在热爱之前，请先热爱自己每天要做的事情，好好打起精神吧。 ​ 寒假要加油，数学已经这么差了，我想你也没资格安逸了吧。","categories":[{"name":"dishonor","slug":"dishonor","permalink":"http://endsieg77.github.io/categories/dishonor/"}],"tags":[{"name":"retrospect","slug":"retrospect","permalink":"http://endsieg77.github.io/tags/retrospect/"}]},{"title":"Advanced Algebra & Analysing Geometry","date":"2021-01-08T04:10:13.000Z","path":"2021/01/08/Advanced-Algebra-Analysing-Geometry/","text":"多项式 在实数域上，多项式必然可以分解为：\\\\\\ f(x)=a_n(x-\\alpha_1)^{l_1}(x-\\alpha_2)^{l_2}...(x^2+p_1x+q_1)^{k_1}(x^2+p_2x+q_2)^{k_2}...\\\\ 故可以得到结论：\\\\奇次多项式必然在实数域上可约平面束 平面束分为，有轴平面束和平行平面束。 空间中通过同一条直线的所有平面的集合叫做有轴平面束。 空间中平行与同一个平面的所有平面的集合叫做平行平面束。 有轴平面束 有两个平面：\\\\ \\pi_1:A_1x+B_1y+C_1z+D_1=0,\\\\ \\pi_2:A_2x+B_2y+C_2z+D_2=0,\\\\ 交于一条直线L，那么以直线L为轴的有轴平面束方程为：\\\\ l(A_1x+B_1y+C_1z+D_1)+m(A_2x+B_2y+C_2z+D_2)=0\\\\ (l\\cdot{m}\\neq{0})平行平面束 有两个平面：\\\\ \\pi_1:A_1x+B_1y+C_1z+D_1=0,\\\\ \\pi_2:A_2x+B_2y+C_2z+D_2=0,\\\\ 互相平行，那么：\\\\ l(A_1x+B_1y+C_1z+D_1)+m(A_2x+B_2y+C_2z+D_2)=0\\\\ (l\\cdot{m}\\neq{0})\\\\ 构成平行平面束。伴随矩阵 (1)A可逆当且仅当A^*可逆\\\\ (2)若A可逆则A^*=|A|A^{-1}\\\\ (3)对于A^*的秩有：\\\\ r(A^*)=n,r(A)=n\\\\ r(A^*)=1,r(A)=n-1\\\\ r(A^*)=0,r(A)|A^*A|=|A|^{n}\\\\=>|A^*|=|A|^{n-1}\\\\A Classic Formula (A,B)\\longrightarrow(E,A^{-1}B)\\\\ 用分块矩阵乘法可以简单证明。","categories":[{"name":"Maths","slug":"Maths","permalink":"http://endsieg77.github.io/categories/Maths/"}],"tags":[{"name":"algebra_and_geometry","slug":"algebra-and-geometry","permalink":"http://endsieg77.github.io/tags/algebra-and-geometry/"},{"name":"basic","slug":"basic","permalink":"http://endsieg77.github.io/tags/basic/"}]},{"title":"functional_foundations","date":"2021-01-07T19:48:32.000Z","path":"2021/01/08/functional-foundations/","text":"Y CombinatorLambda Calculus realizes recursion by: \\lambda{f.}(\\lambda{x}.f(x\\space{x}))(\\lambda{x}.f(x\\space{x})), which was created by Haskell.","categories":[{"name":"functional","slug":"functional","permalink":"http://endsieg77.github.io/categories/functional/"}],"tags":[{"name":"utilities","slug":"utilities","permalink":"http://endsieg77.github.io/tags/utilities/"}]},{"title":"c_file","date":"2021-01-07T09:36:18.000Z","path":"2021/01/07/c-file/","text":"12345678910111213141516171819202122/* file I/O */size_t fread(void *buffer, size_t size, size_t count, FILE *fstream);size_t fwrite(void *buffer, size_t size, size_t count, FILE *fstream);int feof(FILE *fstream);void rewind(FILE *fstream); /* rewind to the BOF */void fseek(FILE *fstream, long offset, int fromwhere);/** SEEK_SET(beginning) Macro defined 0 * SEEK_CUR(current) Macro defined 1 * SEEK_END(end) Macro defined 2 */void fclose(FILE *fstream); /* shall be paired with fopen() */void fputc(char c, FILE *fstream);void fputs(char *string, FILE *fstream);/* different from fputc/s, the 1st param of fprintf/scanf is a file pointer */int fprintf(FILE *stream, const char *format, ...);int fscanf(FILE *stream, const char *format, ...);/* sort function included in stdlib.h: */void qsort(void *base, /* Pointer to the array */ size_t num, /* Length of the array */ size_t width, /* Size of the elems */ int(__cdecl*compare)(const void*,const void*));","categories":[{"name":"C","slug":"C","permalink":"http://endsieg77.github.io/categories/C/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://endsieg77.github.io/tags/basic/"}]},{"title":"my_header_library","date":"2021-01-07T08:49:38.000Z","path":"2021/01/07/my-header-library/","text":"Overview​ In this markdown I will share my realization of some classic containers and polynomial division. ​ Capacity limited, as a result they might seem to be quite foolish loool. Section 1: ContainersForward declarations“standard_container.h”12345678#ifndef __STANDARD_CONTAINER_H__#define __STANDARD_CONTAINER_H__#include &quot;heap.h&quot;#include &quot;array.h&quot;#include &quot;lists.h&quot;#endif “lists.h”1234567#ifndef __LISTS_H__#define __LISTS_H__#include &quot;link_list.h&quot;#include &quot;loop_list.h&quot;#endif “listfwd.h”12345678910111213#ifndef __LISTFWD_H__#define __LISTFWD_H__#include &lt;iosfwd&gt;#include &lt;functional&gt;template&lt;class T&gt; class LinkList;template&lt;class T&gt; class LoopList;template&lt;class T&gt; class LinkListNode;template&lt;class T&gt; LinkListNode&lt;T&gt; *moveForwards(LinkListNode&lt;T&gt;*&amp;);template&lt;class T&gt; LinkListNode&lt;T&gt; *moveBackwards(LinkListNode&lt;T&gt;*&amp;);#endif Link List“link_list.h”123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306// LinkList.hpp// This header file contains some// facilities of data structure LinkList.// Copyright(c) @ Offensive77#ifndef __LINKLIST_H__#define __LINKLIST_H__#include &quot;listfwd.h&quot;template&lt;class T&gt;class LinkListNode&#123;public: typedef std::bidirectional_iterator_tag iterator_category; friend class LinkList&lt;T&gt;; friend class LoopList&lt;T&gt;;private: T data; LinkListNode *next; LinkListNode *prev; LinkList&lt;T&gt; *belongsTo; // Introduction to superior abstract. // Derived Class can also be considered in this case.public: LinkListNode( T dat, LinkList&lt;T&gt; *bT = nullptr, LinkListNode *pPtr = nullptr, LinkListNode *nPtr = nullptr ) : data(dat), belongsTo(bT), prev(pPtr), next(nPtr) &#123; if(bT&amp;&amp;bT!=belongsTo) &#123; ++bT-&gt;len; bT-&gt;tailInsert(dat); &#125; &#125; LinkListNode(const LinkListNode *&amp;lln) &#123; data = lln-&gt;data; next = lln-&gt;next; prev = lln-&gt;prev; belongsTo = lln-&gt;belongsTo; &#125; ~LinkListNode() = default; T getValue() const; friend LinkListNode *moveBackwards&lt;T&gt;(LinkListNode*&amp;); friend LinkListNode *moveForwards&lt;T&gt;(LinkListNode*&amp;); LinkListNode *erase(); LinkList&lt;T&gt; *comeFrom() const;&#125;;template&lt;class T&gt;inline T LinkListNode&lt;T&gt;::getValue() const&#123; if(belongsTo-&gt;empty()) return 0; return this-&gt;data;&#125;template&lt;class T&gt;LinkListNode&lt;T&gt; *moveBackwards(LinkListNode&lt;T&gt; *&amp;node)&#123; if(node)node = node-&gt;prev; return node;&#125;template&lt;class T&gt;LinkListNode&lt;T&gt; *moveForwards(LinkListNode&lt;T&gt; *&amp;node)&#123; if(node)node = node-&gt;next; return node;&#125;template&lt;class T&gt;LinkListNode&lt;T&gt; *LinkListNode&lt;T&gt;::erase()&#123; if(belongsTo-&gt;empty())return nullptr; --(belongsTo-&gt;len); if(this == belongsTo-&gt;head) &#123; auto temp = this-&gt;next; if(temp) temp-&gt;prev = nullptr; belongsTo-&gt;head = temp; delete this; /* Member function can not visit class&#x27;s members after being deleted. */ return temp; &#125; if(this == belongsTo-&gt;tail) &#123; delete this; return nullptr; &#125; auto temp = this-&gt;next; this-&gt;prev-&gt;next = this-&gt;next; this-&gt;next-&gt;prev = this-&gt;prev; return temp;&#125;template&lt;class T&gt;inline LinkList&lt;T&gt; *LinkListNode&lt;T&gt;::comeFrom() const&#123; return this-&gt;belongsTo;&#125;// LinkList is defined as below:template&lt;class T&gt;class LinkList&#123; friend class LinkListNode&lt;T&gt;;protected: LinkListNode&lt;T&gt; *head; LinkListNode&lt;T&gt; *tail; int len;public: LinkList(LinkListNode&lt;T&gt; *hPtr = nullptr, LinkListNode&lt;T&gt; *tPtr = nullptr): head(hPtr), tail(tPtr), len(0) &#123; if(hPtr)&#123; ++len; hPtr-&gt;belongsTo = this; &#125; if(tPtr) &#123; ++len; tPtr-&gt;belongsTo = this; this-&gt;tail-&gt;prev = this-&gt;head; this-&gt;head-&gt;next = this-&gt;tail; this-&gt;tail-&gt;next = nullptr; this-&gt;head-&gt;prev = nullptr; &#125; &#125; LinkList(std::initializer_list&lt;T&gt; init_lst): head(nullptr), tail(nullptr), len(0) &#123; for(auto elem : init_lst) this-&gt;tailInsert(elem); &#125; virtual ~LinkList() = default; virtual void headInsert(const T&amp;); virtual void tailInsert(const T&amp;); virtual void insert(LinkListNode&lt;T&gt;*, const T&amp;); int length() const; LinkListNode&lt;T&gt; *begin() const; LinkListNode&lt;T&gt; *end() const; virtual void displayList(const bool&amp; = 1) const; bool empty() const; LinkList operator+(const LinkList&amp;); LinkList &amp;operator+=(const LinkList&amp;); LinkList &amp;operator=(const LinkList&amp;); bool &amp;operator==(const LinkList&amp;); bool &amp;operator!=(const LinkList&amp;); friend void operator&lt;&lt;(std::ostream &amp;os, const LinkList &amp;LL) &#123; LL.displayList(); &#125; // the reference to constant member or constant member // itself can only call the const member function // with regard to the possibility of being hacked.&#125;;//template&lt;class T&gt;void LinkList&lt;T&gt;::headInsert(const T &amp;newData)&#123; ++len; LinkListNode&lt;T&gt; *newNode = new LinkListNode&lt;T&gt;(newData, this); if(!head&amp;&amp;!tail) &#123; this-&gt;tail = newNode; return; &#125; if(!head&amp;&amp;tail) &#123; this-&gt;head =newNode; this-&gt;head-&gt;next = this-&gt;tail; this-&gt;tail-&gt;prev = this-&gt;head; return; &#125; this-&gt;head-&gt;prev = newNode; newNode-&gt;next = this-&gt;head; this-&gt;head = newNode;&#125;template&lt;class T&gt;void LinkList&lt;T&gt;::tailInsert(const T &amp;newData)&#123; ++len; LinkListNode&lt;T&gt; *newNode = new LinkListNode&lt;T&gt;(newData, this); if(!head&amp;&amp;!tail) &#123; this-&gt;head = newNode; return; &#125; if(head&amp;&amp;!tail) &#123; this-&gt;tail =newNode; this-&gt;head-&gt;next = this-&gt;tail; this-&gt;tail-&gt;prev = this-&gt;head; return; &#125; this-&gt;tail-&gt;next = newNode; newNode-&gt;prev = this-&gt;tail; this-&gt;tail = newNode;&#125;template&lt;class T&gt;void LinkList&lt;T&gt;::insert(LinkListNode&lt;T&gt; *After, const T &amp;newData)&#123; if(After == tail) &#123; tailInsert(newData); return; &#125; ++len; LinkListNode&lt;T&gt; *newNode = new LinkListNode&lt;T&gt;(newData, this); newNode-&gt;next = After-&gt;next; newNode-&gt;prev = After; After-&gt;next-&gt;prev = newNode; After-&gt;next = newNode;&#125;template&lt;class T&gt;inline LinkListNode&lt;T&gt; *LinkList&lt;T&gt;::begin() const&#123; if(this-&gt;empty())return nullptr; if(!head)return this-&gt;head-&gt;next; return this-&gt;head;&#125;template&lt;class T&gt;inline LinkListNode&lt;T&gt; *LinkList&lt;T&gt;::end() const&#123; if(this-&gt;empty())return nullptr; if(!tail)return this-&gt;tail-&gt;prev; return this-&gt;tail;&#125;template&lt;class T&gt;inline int LinkList&lt;T&gt;::length() const&#123; return this-&gt;len;&#125;template&lt;class T&gt;void LinkList&lt;T&gt;::displayList(const bool&amp; ctrl_arg) const&#123; if(empty())return; if(ctrl_arg) &#123; auto iter = begin(); while(iter) &#123; std::cout&lt;&lt;iter-&gt;getValue(); if(iter-&gt;next)std::cout&lt;&lt;&#x27; &#x27;; moveForwards(iter); &#125; return; &#125; else &#123; auto iter = end(); while(iter) &#123; std::cout&lt;&lt;iter-&gt;getValue(); if(iter-&gt;prev)std::cout&lt;&lt;&#x27; &#x27;; moveBackwards(iter); &#125; return; &#125;&#125;template&lt;class T&gt;inline bool LinkList&lt;T&gt;::empty() const&#123; if(!len)return true; return false;&#125;template&lt;class T&gt;LinkList&lt;T&gt; LinkList&lt;T&gt;::operator+(const LinkList&lt;T&gt; &amp;anotherList)&#123; // refer to anotherList to avoid the cost of copying it LinkList&lt;T&gt; temp = LinkList&lt;T&gt;(); auto iter1 = this-&gt;begin(), iter2 = anotherList.begin(); while(iter1) &#123; temp.tailInsert(iter1-&gt;data); moveForwards(iter1); &#125; while(iter2) &#123; temp.tailInsert(iter2-&gt;data); moveForwards(iter2); &#125; // implicitly call the constructor at the exit point (if any // temporary object exists) return temp;&#125;#endif “loop_list.h”123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &quot;link_list.h&quot;// LoopList is defined as below:template&lt;class T&gt;class LoopList : public LinkList&lt;T&gt;&#123;private: bool hasCircle;public: LoopList(LinkListNode&lt;T&gt;* hPtr = nullptr, LinkListNode&lt;T&gt;* tPtr = nullptr) : LinkList&lt;T&gt;(hPtr, tPtr) &#123; Close(); &#125; LoopList(std::initializer_list&lt;T&gt; init_lst) : LinkList&lt;T&gt;(init_lst) &#123; Close(); &#125; LoopList(const LinkList&lt;T&gt; &amp;another_linklist) : LinkList&lt;T&gt;(another_linklist) &#123; Close(); &#125; ~LoopList() = default; void displayList(const bool &amp; = 1) const override; void Close(); bool isClosed();&#125;;template&lt;class T&gt;void LoopList&lt;T&gt;::Close()&#123; if(this-&gt;tail) &#123; this-&gt;head-&gt;prev = this-&gt;tail; this-&gt;tail-&gt;next = this-&gt;head; hasCircle = 1; &#125; else hasCircle = 0;&#125;template&lt;class T&gt;inline bool LoopList&lt;T&gt;::isClosed()&#123; return hasCircle;&#125;template&lt;class T&gt;void LoopList&lt;T&gt;::displayList(const bool &amp;ctrl_arg) const&#123; if(this-&gt;empty())return; int counted = 0; auto iter = ctrl_arg ? this-&gt;begin() : this-&gt;end(); std::function&lt;LinkListNode&lt;T&gt;*(LinkListNode&lt;T&gt;*&amp;)&gt; dir &#123; ctrl_arg ? moveForwards&lt;T&gt;: moveBackwards&lt;T&gt; &#125;; while(1) &#123; ++counted; auto val = iter-&gt;getValue(); std::cout &lt;&lt; val; // std::cout &lt;&lt; iter-&gt;getValue(); if(this-&gt;len - counted) std::cout&lt;&lt;&#x27; &#x27;; if(counted == this-&gt;len) return; dir(iter); &#125;&#125; Array“array.h”123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#ifndef __LiNEAR_TABLE_H__#define __LiNEAR_TABLE_H__#include &lt;initializer_list&gt;template&lt;class _Ty, size_t _Size&gt;class Array;template&lt;class _Ty, size_t _Size&gt;class Array&#123;public: typedef std::random_access_iterator_tag iterator_category; typedef _Ty value_type; typedef _Ty* iterator; typedef const _Ty* const_iterator; typedef _Ty&amp; reference; typedef const _Ty&amp; const_reference;public: explicit Array() noexcept; explicit Array(const _Ty&amp;) noexcept; explicit Array(_Ty&amp;) noexcept; explicit Array(_Ty&amp;&amp;) noexcept; explicit Array(const _Ty*) noexcept; Array(const std::initializer_list&lt;_Ty&gt;&amp;) noexcept; Array(std::initializer_list&lt;_Ty&gt;&amp;) noexcept; Array(std::initializer_list&lt;_Ty&gt;&amp;&amp;) noexcept; Array(const Array&amp;) noexcept; ~Array() noexcept; iterator begin() const noexcept; iterator last() const noexcept; iterator end() const noexcept; constexpr const_iterator cbegin() const noexcept; /* yield */ constexpr const_iterator clast() const noexcept; /* read-only */ constexpr const_iterator cend() const noexcept; /* iterators */ constexpr size_t size() const noexcept; value_type max() const; value_type min() const; void remove() const; const_reference operator[](const size_t&amp;) const noexcept; reference operator[](const size_t&amp;) noexcept;private: void __init__(const _Ty&amp;); void __init__(const std::initializer_list&lt;_Ty&gt;&amp;); iterator __beg; iterator __ed;&#125;; template&lt;class _Ty, size_t _Size&gt;Array&lt;_Ty, _Size&gt;::Array() noexcept : __beg(new _Ty[_Size]), __ed(__beg + _Size)&#123;&#125;template&lt;class _Ty, size_t _Size&gt;Array&lt;_Ty, _Size&gt;::Array( const _Ty &amp; __init_value ) noexcept&#123; __init__(__init_value); &#125;template&lt;class _Ty, size_t _Size&gt;Array&lt;_Ty, _Size&gt;::Array( _Ty &amp;__init_value ) noexcept : Array(std::move(__init_value))&#123;&#125;template&lt;class _Ty, size_t _Size&gt;Array&lt;_Ty, _Size&gt;::Array( _Ty &amp;&amp;__init_value ) noexcept : Array()&#123; __init__(__init_value); &#125;template&lt;class _Ty, size_t _Size&gt;Array&lt;_Ty, _Size&gt;::Array( const _Ty *__Arr ) noexcept : Array()&#123; std::copy( __Arr, __Arr + _Size, __beg );&#125;template&lt;class _Ty, size_t _Size&gt;Array&lt;_Ty, _Size&gt;::Array( const std::initializer_list&lt;_Ty&gt;&amp; _init_lst ) noexcept : Array()&#123; __init__(_init_lst); &#125;template&lt;class _Ty, size_t _Size&gt;Array&lt;_Ty, _Size&gt;::Array( std::initializer_list&lt;_Ty&gt;&amp; _init_lst ) noexcept : Array(std::move(_init_lst))&#123;&#125;template&lt;class _Ty, size_t _Size&gt;Array&lt;_Ty, _Size&gt;::Array( std::initializer_list&lt;_Ty&gt;&amp;&amp; _init_lst ) noexcept : Array()&#123; __init__(_init_lst); &#125;template&lt;class _Ty, size_t _Size&gt;Array&lt;_Ty, _Size&gt;::Array( const Array &amp; _another_Arr ) noexcept : Array()&#123; std::copy( _another_Arr.begin(), _another_Arr.end(), __beg );&#125;template&lt;class _Ty, size_t _Size&gt;Array&lt;_Ty, _Size&gt;::~Array() noexcept= default;template&lt;class _Ty, size_t _Size&gt;inlinetypename Array&lt;_Ty, _Size&gt;::iterator Array&lt;_Ty, _Size&gt;::begin() const noexcept&#123; return __beg; &#125;template&lt;class _Ty, size_t _Size&gt;inlinetypename Array&lt;_Ty, _Size&gt;::iterator Array&lt;_Ty, _Size&gt;::last() const noexcept&#123; return __ed - 1; &#125;template&lt;class _Ty, size_t _Size&gt;inlinetypename Array&lt;_Ty, _Size&gt;::iterator Array&lt;_Ty, _Size&gt;::end() const noexcept&#123; return __ed; &#125;template&lt;class _Ty, size_t _Size&gt;inline constexprtypename Array&lt;_Ty, _Size&gt;::const_iterator Array&lt;_Ty, _Size&gt;::cbegin() const noexcept&#123; return __beg; &#125;template&lt;class _Ty, size_t _Size&gt;inline constexprtypename Array&lt;_Ty, _Size&gt;::const_iterator Array&lt;_Ty, _Size&gt;::clast() const noexcept&#123; return __ed - 1; &#125;template&lt;class _Ty, size_t _Size&gt;inline constexprtypename Array&lt;_Ty, _Size&gt;::const_iterator Array&lt;_Ty, _Size&gt;::cend() const noexcept&#123; return __ed; &#125;template&lt;class _Ty, size_t _Size&gt;inline constexpr size_t Array&lt;_Ty, _Size&gt;::size() const noexcept&#123; return _Size; &#125;template&lt;class _Ty, size_t _Size&gt;_Ty Array&lt;_Ty, _Size&gt;::max() const&#123; _Ty __Cmp = *begin(); for(auto __item: begin()) __Cmp = __Cmp &gt; __item ? __Cmp : __item; return __Cmp;&#125;template&lt;class _Ty, size_t _Size&gt;_Ty Array&lt;_Ty, _Size&gt;::min() const&#123; _Ty __Cmp = *begin(); for(auto __item: begin()) __Cmp = __Cmp &lt; __item ? __Cmp : __item; return __Cmp;&#125;template&lt;class _Ty, size_t _Size&gt;inline void Array&lt;_Ty, _Size&gt;::remove() const&#123; delete[] __beg; &#125;template&lt;class _Ty, size_t _Size&gt;inlinetypename Array&lt;_Ty, _Size&gt;::const_reference Array&lt;_Ty, _Size&gt;::operator[](const size_t &amp;__index) const noexcept&#123; return *(begin() + __index); &#125;template&lt;class _Ty, size_t _Size&gt;inlinetypename Array&lt;_Ty, _Size&gt;::reference Array&lt;_Ty, _Size&gt;::operator[](const size_t &amp;__index) noexcept&#123; return const_cast&lt;_Ty&amp;&gt;( static_cast&lt;const Array&amp;&gt;(*this) [__index] );&#125;template&lt;class _Ty, size_t _Size&gt;inlinevoid Array&lt;_Ty, _Size&gt;::__init__(const _Ty &amp;__init_value)&#123; auto __item = begin() - 1; for(; ++__item != __ed;) *__item = __init_value;&#125;template&lt;class _Ty, size_t _Size&gt;inlinevoid Array&lt;_Ty, _Size&gt;::__init__( const std::initializer_list&lt;_Ty&gt; &amp;_init_lst )&#123; size_t __index = -1; for(auto __item: _init_lst) *(begin() + (++__index)) = __item;&#125;#endif Heap“heap.h”123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#ifndef __HEAP_H__#define __HEAP_H__#define _BIG_ROOT_HEAP_ 0#define _SMALL_ROOT_HEAP_ 1#include&lt;vector&gt;template&lt;class _Ty&gt; class Heap;template&lt;class _Ty&gt;class Heap&#123;public: Heap(std::initializer_list&lt;_Ty&gt;, const bool&amp; = _BIG_ROOT_HEAP_) noexcept; ~Heap() noexcept; size_t insert(const _Ty&amp;); bool remove_root(); size_t size() const; const _Ty root_item() const; constexpr bool _whoami() const; bool empty() const;private: std::vector&lt;_Ty&gt; _Elems; size_t _size; const bool _style; bool nodecmp(const size_t&amp;, const size_t&amp;) const; size_t _parent(const size_t&amp;) const; size_t l_child(const size_t&amp;) const; size_t r_child(const size_t&amp;) const;&#125;;template&lt;class _Ty&gt;Heap&lt;_Ty&gt;::Heap(std::initializer_list&lt;_Ty&gt; _lst, const bool &amp;_flg) noexcept : _size(0), _style(_flg)&#123; for(auto _item: _lst) insert(_item);&#125;template&lt;class _Ty&gt;Heap&lt;_Ty&gt;::~Heap() noexcept&#123;&#125;template&lt;class _Ty&gt;inlinebool Heap&lt;_Ty&gt;::nodecmp(const size_t &amp;_node, const size_t &amp;_another) const&#123; if(_style) return _Elems[_node] &lt;= _Elems[_another]; return _Elems[_node] &gt;= _Elems[_another];&#125;template&lt;class _Ty&gt;size_t Heap&lt;_Ty&gt;::insert(const _Ty &amp;_nItem)&#123; ++_size; if(_size == 1 &amp;&amp; !_Elems.empty()) &#123; _Elems[0] = _nItem;return 0; &#125; size_t _pos = _size - 1; _Elems.push_back(_nItem); while(_pos != 0) &#123; size_t parent = _parent(_pos); if(nodecmp(parent, _pos)) break; _Ty _temp = _Elems[_pos]; _Elems[_pos] = _Elems[parent]; _Elems[parent] = _temp; _pos=parent; &#125; return _pos;&#125;template&lt;class _Ty&gt;bool Heap&lt;_Ty&gt;::remove_root()&#123; if(!_size) &#123; std::cerr&lt;&lt;&quot;Heap Underflow\\n&quot;; &#125; else if(_size == 1) &#123; --_size;return false; &#125; _Ty _temp = _Elems[0]; _Elems[0] = _Elems[_size - 1]; _Elems.erase(_Elems.begin() + _size - 1); --_size; size_t _index = 0; while(1) &#123; size_t lchild = l_child(_index), rchild = r_child(_index); if(lchild &gt;= _size - 1) lchild = _index; if(rchild &gt;= _size - 1) rchild = _index; if(nodecmp(_index, lchild) &amp;&amp; nodecmp(_index, rchild)) break; size_t swap_child = nodecmp(lchild, rchild) ? lchild: rchild; _Ty _temp = _Elems[swap_child]; _Elems[swap_child] = _Elems[_index]; _Elems[_index] = _temp; _index = swap_child; &#125; return true;&#125;template&lt;class _Ty&gt;inlinesize_t Heap&lt;_Ty&gt;::size() const &#123; return _size;&#125;template&lt;class _Ty&gt;inlineconst _Ty Heap&lt;_Ty&gt;::root_item() const&#123; return _Elems[0];&#125;template&lt;class _Ty&gt;inlinesize_t Heap&lt;_Ty&gt;::_parent(const size_t &amp;_curr) const&#123; return (_curr - 1) / 2;&#125;template&lt;class _Ty&gt;inlinesize_t Heap&lt;_Ty&gt;::l_child(const size_t &amp;_parent) const&#123; return _parent * 2 + 1;&#125;template&lt;class _Ty&gt;inlinesize_t Heap&lt;_Ty&gt;::r_child(const size_t &amp;_parent) const&#123; return _parent * 2 + 2;&#125;template&lt;class _Ty&gt;inlineconstexpr bool Heap&lt;_Ty&gt;::_whoami() const &#123; if(_style) return _SMALL_ROOT_HEAP_; return _BIG_ROOT_HEAP_;&#125;template&lt;class _Ty&gt;inlinebool Heap&lt;_Ty&gt;::empty() const&#123; return _size &gt; 0;&#125;#endif Section 2: Polynomial DivisionForward declarations“fractionfwd.h”12345678910111213141516171819202122232425262728293031323334353637383940/** This header contains the forward declarations * of class fraction, multinomial, complex etc. */ #ifndef __FRACTIONFWD_H__#define __FRACTIONFWD_H__#include &lt;map&gt;#include &lt;iosfwd&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;functional&gt;class complex;class fraction;class polynomial;using _multimap = std::map&lt;long long, fraction&gt;;using _multipair = std::pair&lt;long long, fraction&gt;;/* fraction-related facilities defined as below: */ fraction getfrac() noexcept;fraction operator+(const fraction&amp;, const fraction&amp;) noexcept;fraction operator-(const fraction&amp;, const fraction&amp;) noexcept;fraction operator*(const fraction&amp;, const fraction&amp;) noexcept;fraction operator/(const fraction&amp;, const fraction&amp;) noexcept;bool operator==(const fraction&amp;, const fraction&amp;) noexcept;bool operator!=(const fraction&amp;, const fraction&amp;) noexcept;bool operator&gt;(const fraction&amp;, const fraction&amp;) noexcept;bool operator&gt;=(const fraction&amp;, const fraction&amp;) noexcept;bool operator&lt;(const fraction&amp;, const fraction&amp;) noexcept;bool operator&lt;=(const fraction&amp;, const fraction&amp;) noexcept;// std::istream&amp; operator&gt;&gt;(std::istream&amp;, fraction) noexcept;std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const fraction&amp;) noexcept;/* polynomial-related facilities defined as below: */polynomial gcf(const polynomial&amp;, const polynomial&amp;) noexcept;#endif Implements“fraction.h”123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322/*=================================================================================* *= Header name: &quot;fraction.h&quot; = *= Description: This header includes some updated facilities of fraction. = *= Rewritten on: 2020/12/5 Sat = *= Author: Offensive77 = *= Version: 1.1.0 = *= Copyright reserved. = *=================================================================================*/ #ifndef __FRACTION_H__#define __FRACTION_H__#define __ABS(x) ((x) &gt;= 0 ? (x) : -(x))#define Frac(x) typeid(x) == typeid(NULL) ? \\ fraction(#x) : fraction(x)#define New_Frac(x) typeid(x) == typeid(NULL) ? \\ new fraction(#x) : new fraction(x)#define Unique_Frac(x) typeid(x) == typeid(NULL) ? \\ std::make_unique&lt;fraction&gt;(#x) : std::make_unique&lt;fraction&gt;(x)#include &quot;fractionfwd.h&quot;std::function&lt;const long long(const long long&amp;, const long long&amp;)&gt; packaged_greatest_common_divisor =[](const long long&amp; __1, const long long&amp; __2) -&gt; const long long&#123; return __1 % __2 ? packaged_greatest_common_divisor(__2, __1 % __2) : __2;&#125;;// An interface for gcd algorithm, also for initialization.auto greatest_common_divisor =[](const long long&amp; __1, const long long&amp; __2)&#123; bool symb = (__2 &gt; 0) ? true : false; const long long&amp; __3 = __ABS(__1) &gt;= __ABS(__2) ? __ABS(__1) : __ABS(__2); const long long&amp; __4 = __ABS(__1) &lt; __ABS(__2) ? __ABS(__1) : __ABS(__2); if (symb) return __3 % __4 ? packaged_greatest_common_divisor(__4, __3 % __4) : __4; // Else situation return - (__3 % __4 ? packaged_greatest_common_divisor(__ABS(__4), __ABS(__3) % __ABS(__4)) : __ABS(__4));&#125;;auto least_common_multiplier =[](const long long __1, const long long __2) -&gt;const long long&#123; return __1 / greatest_common_divisor(__1, __2) * __2;&#125;;class fraction&#123; friend polynomial; friend complex; using LL = long long; using string = std::string;private: LL q; LL p; template &lt;int _Num&gt; void change_at(const LL&amp;) noexcept;public: fraction(const LL&amp; = 0, const LL&amp; = 1) noexcept; fraction(LL&amp;, LL&amp;) noexcept; fraction(LL&amp;&amp;, LL&amp;) noexcept; fraction(LL&amp;, LL&amp;&amp;) noexcept; fraction(LL&amp;&amp;, LL&amp;&amp;) noexcept; fraction(const fraction&amp;) noexcept; explicit fraction(const string&amp;) noexcept; explicit fraction(string&amp;) noexcept; explicit fraction(string&amp;&amp;) noexcept; ~fraction() noexcept; void reduction() noexcept; void display() const noexcept; void to_latex() const noexcept; string to_string() const noexcept; const LL get_at(const bool&amp;) const noexcept; fraction operator+=(const fraction&amp;) noexcept; fraction operator-=(const fraction&amp;) noexcept; fraction operator*=(const fraction&amp;) noexcept; fraction operator/=(const fraction&amp;) noexcept; fraction&amp; operator=(const fraction&amp;) noexcept; // friend std::istream&amp; operator&gt;&gt;(std::istream&amp;, fraction) noexcept; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const fraction&amp;) noexcept; friend fraction getfrac() noexcept; friend polynomial gcf(const polynomial&amp;, const polynomial&amp;) noexcept;&#125;;inline fraction::fraction(const LL&amp; _q, const LL&amp; _p) noexcept : q(_q), p(_p) &#123; reduction(); &#125;inline fraction::fraction(LL&amp; _q, LL&amp; _p) noexcept : fraction(std::move(_q), std::move(_p)) &#123;&#125;inline fraction::fraction(LL&amp;&amp; _q, LL&amp; _p) noexcept : fraction(std::move(_q), std::move(_p)) &#123;&#125;inline fraction::fraction(LL&amp; _q, LL&amp;&amp; _p) noexcept : fraction(std::move(_q), std::move(_p)) &#123;&#125;inline fraction::fraction(LL&amp;&amp; _q, LL&amp;&amp; _p) noexcept : q(_q), p(_p) &#123; reduction(); &#125;inline fraction::fraction(const std::string&amp; str_frac) noexcept&#123; size_t len = str_frac.size(); for(size_t i = 0; i &lt; len; ++i) if(str_frac[i] == &#x27;/&#x27;) &#123; q = std::stoll(str_frac.substr(0, i)); p = std::stoll(str_frac.substr(i + 1, len - i - 1)); reduction(); return; &#125; q = std::stoll(str_frac); p = 1;&#125;inline fraction::fraction(std::string&amp; str_frac) noexcept : fraction(std::move(str_frac)) &#123;&#125;inline fraction::fraction(std::string&amp;&amp; str_frac) noexcept&#123; size_t len = str_frac.size(); for(size_t i = 0; i &lt; len; ++i) if(str_frac[i] == &#x27;/&#x27;) &#123; q = std::stoll(str_frac.substr(0, i)); p = std::stoll(str_frac.substr(i + 1, len - i - 1)); reduction(); return; &#125; q = std::stoll(str_frac); p = 1;&#125;inline fraction::fraction(const fraction&amp; frac) noexcept&#123; q = frac.q; p = frac.p;&#125;inline fraction::~fraction() noexcept &#123;&#125;inline std::string fraction::to_string() const noexcept&#123; return p == 1 ? std::to_string(q) : std::to_string(q) + &quot;/&quot; + std::to_string(p); &#125;inline const long long fraction::get_at(const bool &amp;_tag) const noexcept&#123; if(_tag) return p; return q;&#125;template &lt;int _Num&gt;inline void fraction::change_at(const long long&amp; num) noexcept&#123; if(_Num) p = num; q = num;&#125;void fraction::reduction() noexcept&#123; if(!q) &#123; p = 1;return; &#125; LL z = greatest_common_divisor(q, p); p /= z; q /= z; if(p * q &lt; 0) &#123; q = -__ABS(q);p = __ABS(p); &#125;&#125;void fraction::display() const noexcept&#123; if(p!=1) printf(&quot;%lld/%lld&quot;, q ,p); else printf(&quot;%lld&quot;, q);&#125;void fraction::to_latex() const noexcept&#123; if(q &gt; 0 &amp;&amp; p!=1) printf(&quot;\\\\frac&#123;%lld&#125;&#123;%lld&#125;&quot;, q ,p); else if(q &gt; 0) printf(&quot;&#123;%lld&#125;&quot;, q); else if(q &lt; 0 &amp;&amp; p != 1) printf(&quot;-\\\\frac&#123;%lld&#125;&#123;%lld&#125;&quot;, -q, p); else printf(&quot;-&#123;%lld&#125;&quot;, -q);&#125;inline fraction fraction::operator+=(const fraction&amp; frac) noexcept&#123; *this = *this + frac; return *this;&#125;inline fraction fraction::operator-=(const fraction&amp; frac) noexcept&#123; *this = *this - frac; return *this;&#125;inline fraction fraction::operator*=(const fraction&amp; frac) noexcept&#123; *this = *this * frac; return *this;&#125;inline fraction fraction::operator/=(const fraction&amp; frac) noexcept&#123; *this = *this / frac; return *this;&#125;inline fraction&amp; fraction::operator=(const fraction&amp; frac) noexcept&#123; q = frac.q; p = frac.p; return *this;&#125;std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const fraction&amp; frac) noexcept&#123; if(frac.p == 1) printf(&quot;%lld&quot;, frac.q); else printf(&quot;%lld/%lld&quot;, frac.q, frac.p); return os;&#125;fraction getfrac() noexcept&#123; std::string str_frac; std::cin &gt;&gt; str_frac; return fraction(str_frac);&#125;inline fraction operator+(const fraction &amp;lhs, const fraction &amp;rhs) noexcept&#123; auto z = least_common_multiplier(lhs.get_at(1), rhs.get_at(1)); return fraction(z / lhs.get_at(1) * lhs.get_at(0) + z / rhs.get_at(1) * rhs.get_at(0), z);&#125;inline fraction operator-(const fraction &amp;lhs, const fraction &amp;rhs) noexcept&#123; auto z = least_common_multiplier(lhs.get_at(1), rhs.get_at(1)); return fraction(z / lhs.get_at(1) * lhs.get_at(0) - z / rhs.get_at(1) * rhs.get_at(0), z);&#125;inline fraction operator*(const fraction &amp;lhs, const fraction &amp;rhs) noexcept&#123; return fraction(lhs.get_at(0) * rhs.get_at(0), lhs.get_at(1) * rhs.get_at(1)); &#125;inline fraction operator/(const fraction &amp;lhs, const fraction &amp;rhs) noexcept&#123; return fraction(lhs.get_at(0) * rhs.get_at(1), lhs.get_at(1) * rhs.get_at(0)); &#125;inline bool operator==(const fraction &amp;lhs, const fraction &amp;rhs) noexcept&#123; return lhs.get_at(0) * rhs.get_at(1) == lhs.get_at(1) * rhs.get_at(0); &#125;inline bool operator!=(const fraction &amp;lhs, const fraction &amp;rhs) noexcept&#123; return lhs.get_at(0) * rhs.get_at(1) != lhs.get_at(1) * rhs.get_at(0); &#125;inline bool operator&gt;(const fraction &amp;lhs, const fraction &amp;rhs) noexcept&#123; return lhs.get_at(0) * rhs.get_at(1) &gt; lhs.get_at(1) * rhs.get_at(0); &#125;inline bool operator&gt;=(const fraction &amp;lhs, const fraction &amp;rhs) noexcept&#123; return lhs.get_at(0) * rhs.get_at(1) &gt;= lhs.get_at(1) * rhs.get_at(0); &#125;inline bool operator&lt;(const fraction &amp;lhs, const fraction &amp;rhs) noexcept&#123; return lhs.get_at(0) * rhs.get_at(1) &lt; lhs.get_at(1) * rhs.get_at(0); &#125;inline bool operator&lt;=(const fraction &amp;lhs, const fraction &amp;rhs) noexcept&#123; return lhs.get_at(0) * rhs.get_at(1) &lt;= lhs.get_at(1) * rhs.get_at(0); &#125;#undef __INCLUDES__#undef __ABS#endif “polynomial.h”123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294/** This header contains the realization of polynomial division. * Copyright(C) @ Offensive77 */#ifndef __POLYNOMIAL_DIVISION_H_#define __POLYNOMIAL_DIVISION_H_#ifndef MAX_SIZE#define MAX_SIZE 45#endif#ifndef TO_STRING#define TO_STRING 0#endif#define AddItem(x, y) insert(_multipair((x), Frac(y)))#include &quot;fractionfwd.h&quot;#include &quot;fraction.h&quot;class polynomial&#123;public:using LL = long long;private: fraction times[MAX_SIZE]; mutable unsigned degree;public: explicit polynomial() noexcept; explicit polynomial(const std::map&lt;LL, fraction&gt;&amp;) noexcept; ~polynomial() noexcept; void suffix_at(const int&amp;, const bool&amp; = TO_STRING) const noexcept; void to_latex() const noexcept; void display_polynomial(const bool&amp; = TO_STRING) const noexcept; unsigned update_degree() const noexcept; polynomial derivative() const noexcept; polynomial operator/(const polynomial&amp;) const noexcept; polynomial operator%(const polynomial&amp;) const noexcept; polynomial&amp; operator=(const polynomial&amp;) noexcept; friend polynomial process_polynomial(polynomial) noexcept; friend polynomial get_polynomial() noexcept; friend polynomial gcf(const polynomial&amp;, const polynomial&amp;) noexcept;&#125;;inline polynomial::polynomial() noexcept= default;inline polynomial::polynomial(const std::map&lt;LL, fraction&gt;&amp; multi_map) noexcept : polynomial()&#123; signed temp = 0; for(auto _item : multi_map) &#123; times[_item.first] += _item.second; if(_item.first &gt; temp) temp = _item.first; &#125; degree = temp;&#125;inline polynomial::~polynomial() noexcept &#123;&#125;void polynomial::suffix_at( const int&amp; index, const bool&amp; arg ) const noexcept&#123; std::function&lt;void()&gt; fun &#123; arg == TO_STRING ? std::bind( &amp;fraction::display, times[index] ): std::bind( &amp;fraction::to_latex, times[index] ) &#125;; if (!index) fun(); else if( index == 1) &#123; if(times[1] != 1) fun(); printf(&quot;x&quot;); &#125; else if (times[index] == 1) printf(&quot;x^&#123;%d&#125;&quot;, index); else if(times[index] == -1) printf(&quot;-x^&#123;%d&#125;&quot;, index); else &#123; fun(); printf(&quot;x^&#123;%d&#125;&quot;, index); &#125;&#125;void polynomial::display_polynomial(const bool&amp; arg) const noexcept&#123; int deg = degree; if (!deg) &#123; times[0].display(); printf(&quot;\\n&quot;); return; &#125; bool flag = 1; int counted = 0; for (int i = 0; i &lt;= deg; ++i) if (times[i].q) ++counted; for (int i = deg; i &gt;= 0; --i) &#123; if (flag) &#123; flag = 0; suffix_at(i, arg); --counted; continue; &#125; if (times[i] &gt; 0) &#123; printf(&quot;+&quot;); suffix_at(i, arg); --counted; &#125; else if (times[i] &lt; 0) &#123; suffix_at(i, arg); --counted; &#125; if (!counted) &#123; printf(&quot;\\\\\\\\\\n&quot;); break; &#125; &#125;&#125;inline void polynomial::to_latex() const noexcept&#123; display_polynomial(1); &#125;polynomial get_polynomial() noexcept&#123; polynomial result; int temp = -1; fraction m; int n; while (std::cin &gt;&gt; n) &#123; if (n == -1) break; m = getfrac(); result.times[n] += m; if (n &gt; temp) temp = n; &#125; result.degree = temp; return result;&#125;unsigned polynomial::update_degree() const noexcept&#123; for (int i = degree; i &gt;= 1; i--) if (times[i] != 0) &#123; degree = i; return i; &#125; degree = 0; return 0;&#125;polynomial polynomial::derivative() const noexcept&#123; polynomial derivated = *this; derivated.degree = degree - 1; size_t i = 1; for(; i &lt;= degree; ++i) &#123; derivated.times[i - 1] = i * times[i]; &#125; return derivated;&#125;polynomial polynomial::operator/(const polynomial &amp;gx) const noexcept&#123; polynomial fx = *this, qx; if (!degree &amp;&amp; !(gx.degree)) &#123; qx.degree = 0; qx.times[0] = fx.times[0] / gx.times[0]; return qx; &#125; const unsigned &amp;deg = gx.degree; qx.degree = fx.degree - gx.degree; if (qx.degree &lt; 0) qx.degree = 0; while (fx.degree &gt;= deg) &#123; fraction temp = fx.times[fx.degree] / gx.times[deg]; int index = fx.degree - deg; qx.times[index] = temp; for (int j = fx.degree; j &gt;= index; --j) fx.times[j] -= temp * gx.times[j - index]; fx.update_degree(); &#125; return qx;&#125;polynomial polynomial::operator%(const polynomial &amp;gx) const noexcept&#123; polynomial fx = *this, qx; if (!degree &amp;&amp; !(gx.degree)) &#123; fx.degree = 0; fx.times[0].q = 0; return fx; &#125; const unsigned &amp;deg = gx.degree; qx.degree = fx.degree - gx.degree; while (fx.degree &gt;= deg) &#123; fraction temp = fx.times[fx.degree] / gx.times[deg]; int index = fx.degree - deg; qx.times[index] = temp; for (int j = fx.degree; j &gt;= index; j--) fx.times[j] -= temp * gx.times[j - index]; fx.update_degree(); &#125; return fx;&#125;inline polynomial&amp; polynomial::operator=(const polynomial&amp; gx) noexcept&#123; this-&gt;degree = gx.degree; for(int i = degree; i&gt;=0; --i) times[i] = gx.times[i]; return *this;&#125;polynomial process_polynomial(polynomial fx) noexcept&#123; int deg = fx.degree; fraction temp = fx.times[deg]; for (int i = deg; i &gt;= 0; i--) &#123; if (fx.times[i] != 0) fx.times[i] = fx.times[i] / temp; &#125; return fx;&#125;polynomial gcf(const polynomial&amp; fx, const polynomial&amp; gx) noexcept&#123; if (!(fx.degree) &amp;&amp; !(gx.degree)) &#123; polynomial gcfx; if (!(fx.times[0].get_at(0)) &amp;&amp; !(gx.times[0].get_at(0))) gcfx.times[0].change_at&lt;0&gt;(0); else gcfx.times[0].change_at&lt;0&gt;(1); gcfx.degree = 0; return gcfx; &#125; if (!(gx.degree)) return gx; polynomial rx = fx % gx; if (!(rx.degree) &amp;&amp; rx.times[0] == 0) &#123; polynomial res = process_polynomial(gx); return res; &#125; return gcf(gx, rx);&#125;#undef MAX_SIZE#undef TO_STRING#endif End of the file","categories":[{"name":"Cpp","slug":"Cpp","permalink":"http://endsieg77.github.io/categories/Cpp/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://endsieg77.github.io/tags/Data-Structure/"}]},{"title":"思修期末论述题","date":"2021-01-06T15:42:31.000Z","path":"2021/01/06/思修期末论述题/","text":"第一章学习领会正确的人生观，(人生要认真、务实、乐观、进取) 掌握人生价值的正确评价方法(坚持能力有大小和贡献需尽力相统一、物质贡献与精神贡献相统一、完善自身与贡献社会相统一)， 以及在服务人民、奉献社会的实践中创造有意义的人生 第二章了解理想与现实的关系，理解并掌握实现理想的重要条件(辩证看待理想与现实的矛盾;实现理想的长期性、艰巨性和曲折性; 艰苦奋斗是实现理想的重要条件)。 第三章了解改革创新是当代中国最突出、最鲜明的特点。掌握大学生应当将改革创新为己任，成为改革创新的生力军。((一)树立改革创新的自觉意识 (增强改革创新的责任感; 树立敢于突破陈规的意识;树立大胆探索未知领域的信心);(二)增强改革创新的能力本领 (夯实创新基础; 培养创新思维; 投身创新实践)) 第四章理解并掌握大学生如何做社会主义核心价值观的积极践行者。 (扣好人生的扣子;勤学修德明辨笃实;) 第五章理解社会公德的内容，(公共生活与公共秩序;公共生活中的道德规范(文明礼貌;助人为乐;爱护公物;保护环境;遵纪守法)) 掌握网络生活中的道德要求(正确使用网络工具;健康进行网络交往;自觉避免沉迷网络;加强网络道德自律;积极引导网络舆论;)， 掌握大学生提升个人品德的正确方法，(学思并重;省察克治;慎独自律;知行合一;积善成德) 以及锤炼高尚道德品格的途径(形成正确的道德认知和道德判断;激发正向的道德认同和道德情感;强化坚定的道德意志和道德信念)。 第六章了解法治思维的基本含义 (以法治价值和法治精神为指导;以法律原则和法律规则为依据;以法律手段和法律方法为依托;是符合规律、尊重事实的科学思维)， 掌握培养法治思维正确方法， (学习法律知识；掌握法律方法;参与法律实践;养成守法习惯;守住法律底线) 了解坚持依法治国和以德治国的含义， (正确认识法治和德治的地位, 作用, 实现途径;推动法治和德治的相互促进) 理解并掌握推动法治和德治相互作用的方法。 (强化道德对法治的支撑作用;把道德要求贯彻到法治建设中;运用法治手段解决道德领域突出的问题)","categories":[{"name":"Social Science","slug":"Social-Science","permalink":"http://endsieg77.github.io/categories/Social-Science/"}],"tags":[{"name":"awsl","slug":"awsl","permalink":"http://endsieg77.github.io/tags/awsl/"}]},{"title":"Marks of Maths","date":"2021-01-04T14:14:15.000Z","path":"2021/01/04/Marks-of-Maths/","text":"Links: 证明Jensen不等式 一致连续与导数 2021/1/5 Daily Problem:Problem 1: \\int\\sqrt{1+\\frac{1}{4x}}\\mathrm{d}x\\\\ Solution: \\int\\sqrt{1+\\frac{1}{4x}}\\mathrm{d}x\\\\ =\\frac{1}{2}\\int\\sqrt{\\frac{4x+1}{x}}\\mathrm{d}x\\\\ =\\frac{1}{2}\\int\\frac{4x+1}{\\sqrt{x(4x+1)}}\\mathrm{d}x\\\\ =\\frac{1}{2}\\int\\frac{4x+\\frac{1}{2}}{\\sqrt{x(4x+1)}}\\mathrm{d}x +\\frac{1}{4}\\cdot\\frac{\\mathrm{d}x}{\\sqrt{4x^2+x}}\\\\ =\\frac{1}{2}\\sqrt{x(4x+1)}+C_1+\\frac{1}{8}\\cdot\\frac{\\mathrm{d}(8x+1)} {\\sqrt{(8x+1)^2-1}}\\\\ = \\frac{1}{2}\\cdot\\sqrt{x(4x+1)}+\\frac{1}{8}\\ln \\left|{8x+1}+4\\sqrt{4x^2+x}\\right|+CProblem 2: \\int{\\frac{x\\cdot\\cos{x}}{\\sin^3{x}}}\\mathrm{d}x Solution: 令：I=\\int{\\frac{x\\cdot\\cos{x}}{\\sin^3{x}}}\\mathrm{d}x =\\int{x\\cdot\\cot{x}\\cdot\\csc^2{x}}\\mathrm{d}x\\\\ =-\\int{x\\cdot{\\cot{x}}}\\mathrm{d}\\cot{x}\\\\ =-\\left[x\\cdot{\\cot^2{x}}-\\int{\\left[\\cot{x}\\cdot\\left({\\cot{x}-x\\cdot\\csc^2{x}}\\right)\\right]\\mathrm{d}x}\\right]\\\\ =-x\\cdot{\\cot^2{x}}+\\int{\\cot^2{x}\\mathrm{d}x}-I\\\\ =>2\\cdot{I}=-x\\cdot{\\cot^2{x}}+\\int{\\cot^2{x}\\mathrm{d}x} \\\\=-x\\cdot{\\cot^2{x}}+\\int{(\\csc^2{x}-1)\\mathrm{d}x} \\\\=-x\\cdot{\\cot^2{x}}-\\cot{x}-x+C\\\\ 故：I=-\\frac{1}{2}\\left(x\\cdot{\\cot^2{x}}+\\cot{x}+x\\right)+C\\\\参数方程求导 有： \\left\\{ \\begin{array}{ll} y=u(t)\\hbox{,}\\\\ x=v(t)\\hbox{.} \\end{array} \\right.\\\\ 则：\\frac{\\mathrm{d}y}{\\mathrm{d}x} =\\frac{\\mathrm{d}y}{\\mathrm{d}t}\\cdot\\frac{\\mathrm{d}t}{\\mathrm{d}x};\\\\ \\frac{\\mathrm{d^2}y}{\\mathrm{d}x^2} =\\frac{\\mathrm{d}}{\\mathrm{d}x}\\cdot\\frac{\\mathrm{d}y}{\\mathrm{d}x} =\\frac{\\mathrm{d}\\left(\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\right)} {\\mathrm{d}t}\\cdot\\frac{\\mathrm{d}t}{\\mathrm{d}x} =\\frac{\\mathrm{d}\\left(\\frac{\\mathrm{d}y}{\\mathrm{d}x}\\right)} {\\mathrm{d}t}/\\frac{\\mathrm{d}x}{\\mathrm{d}t}\\\\ (须知x, y对t的导数是易得的,在题中x,y对t求导)2020/1/6 Daily Problem:Problem 1: f(x)在[a,b]连续,(a,b)可导，\\\\证明：\\exists\\xi\\in(a,b),s.t.f'(\\xi)=\\frac{f(\\xi)-f(a)}{b-\\xi}. Solution: 分析:不妨先令x=\\xi，对要证明的式子变形:\\\\ f'(x)(b-x)=f(x)-f(a);\\\\ 即:[f'(x)-f(a)]'(b-x)+(b-x)'[f(x)-f(a)];\\\\ 不妨构造辅助函数:\\\\F(x)=[f(x)-f(a)](b-x);\\\\ 再用Rolle定理,以下证明就十分容易了.\\\\ 类似的还有，证明:f'(\\xi)\\pm{g'(\\xi)f(\\xi)};\\\\ 构造辅助函数f'(x)e^{\\pm{g(x)}};\\\\ 有时要结合零点存在性定理.Problem 2: 设f(x)在[a,b]上二阶可导，f'(a)=f'(b)=0.\\\\证明：\\exists\\xi\\in(a,b),s.t. \\frac{4}{(b-a)^2}\\left|f(b)-f(a)\\right|\\le\\left|f''(\\xi)\\right|. Solution: f(x)在x=a和x=b处的带Lagrange余项的Taylor公式分别为:\\\\ f(x)=f(a)+\\frac{f''(\\xi_1)}{2}(x-a)^2;\\\\ f(x)=f(b)+\\frac{f''(\\xi_2)}{2}(x-b)^2;\\\\ 故f(\\frac{a+b}{2})=f(a)+\\frac{f''(\\xi_1)}{8}(b-a)^2\\\\ =f(b)+\\frac{f''(\\xi_2)}{8}(b-a)^2;\\\\ => f(b)-f(a)=\\frac{f''(\\xi_1)-f''(\\xi_2)}{8}(b-a)^2;\\\\ \\therefore \\left|f(b)-f(a)\\right|=\\left|\\frac{f''(\\xi_1)-f''(\\xi_2)}{8}(b-a)^2\\right| \\le\\left|\\frac{f''(\\xi)}{4}(b-a)^2\\right|;\\\\ 其中：f''(\\xi)=\\max\\{|f''(\\xi_1)|,|f''(\\xi_2)|\\}.Problem 3: \\int\\frac{1+\\sin{x}}{1+\\cos{x}}\\cdot{e^x}\\mathrm{d}xSolution: I= \\int\\frac{1+2\\sin{\\frac{x}{2}}\\cdot\\cos{\\frac{x}{2}}}{2\\cos^2{\\frac{x}{2}}}\\mathrm{d}x\\\\ =\\frac{1}{2} \\int{ \\sec^2{\\frac{x}{2}}e^x\\mathrm{d}x+\\int{\\tan{\\frac{x}{2}}}\\mathrm{d}x }\\\\ =\\int{e^x}\\mathrm{d}\\tan{\\frac{x}{2}}+\\int{\\tan{\\frac{x}{2}}}\\cdot{e^x}\\mathrm{d}x\\\\ =\\tan{\\frac{x}{2}}\\cdot{e^x}+CCantor定理 闭区间上的连续函数一致连续。 Lipschitz条件 一致连续\\\\ 若定义在I上的有一阶导的函数f(x)\\\\ 满足|f'(x)|\\le{L},(L为一正常数).\\\\ 则称该函数Lipschitz连续.\\\\ 通俗地说，导函数有界，则原函数一致连续.连续函数的性质 (1)有界性: |f(x)|\\le{M};\\\\ (2)最值性:f(\\xi)\\le{f(x)\\le{f(\\eta)}};\\\\ (3)零点存在定理;\\\\ (4)介值性:R_f\\in[m,M]\\\\ (f(x)可以取遍最大值到最小值之间的每一个值);","categories":[{"name":"Maths","slug":"Maths","permalink":"http://endsieg77.github.io/categories/Maths/"}],"tags":[{"name":"Marks","slug":"Marks","permalink":"http://endsieg77.github.io/tags/Marks/"},{"name":"basic","slug":"basic","permalink":"http://endsieg77.github.io/tags/basic/"}]},{"title":"My_inline_music_box","date":"2021-01-04T13:42:53.000Z","path":"2021/01/04/My-inline-music-box/","text":"​ 今天往博客的Archive里面添加了网易云的外链歌单。期末考试？鸽了。 ​ Reference: Hexo博客添加背景音乐 ​ 歌单: 12345The White Lady - Chirstopher LarkinAs Time Goes By - Max Steinerひとり旅 - 鎖那月夜海 - 藤田咲&#x2F;山田悠希雨き声残響 - 鹿乃 后续: 看到PiCpo用的是APlayer，于是我也去弄了一个 配置 1npm install aplayer --save 往网页的base-head.html里面添加: 123&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js&quot;&gt;&lt;/script&gt; 向博客的_config.yml中加入: 123# APlayer Music Playeraplayer: meting: true 然后再网页中想要插入歌单的部分添加: 1&lt;meting-js server=&quot;netease&quot; type=&quot;playlist&quot; id=&quot;xxx&quot;&gt;&lt;/meting-js&gt; 其中，id为该平台导出外链歌单的值。 meting-js更多的属性详见APlayer的官方文档: APlayer Reference: Aplayer搭配Metingjs音乐插件的使用","categories":[{"name":"hexo","slug":"hexo","permalink":"http://endsieg77.github.io/categories/hexo/"}],"tags":[{"name":"Plugins","slug":"Plugins","permalink":"http://endsieg77.github.io/tags/Plugins/"}]},{"title":"Linux Learning Notes","date":"2021-01-03T19:07:31.000Z","path":"2021/01/04/Linux-Learning-Notes/","text":"Add some aliases for your commands .bashrc is a file that stores the alias of command,its content executed each time the shell is opened.So we can add alias in the file by:1vim $HOME/.bashrcThen, for example, if we wanna use the colored version of lswithout typing “—color” mechanically &amp; repeatedly, add analias ls=”ls —color” at the end of the file. Check your unwired lan driver lspci is a command that lists all your PCI’s conditions.We can check our drivers using grep and pipe: 1lspci | grep -i ethernet Task management We can see the detailed information of our tasksby command jobs -l and:kill them using kill -KILL [pid],stop them using kill -STOP [pid],continue them kill -CONT [pid].If we wanna terminate all our processeskill -KILL -1 halt, shutdown, reboot halt shuts down the system, but users still need to manually turn off the electricity. shutdown requires parameters to function. It will both shut down the system and the electricity. reboot restarts the system. Both of them requires a root authentication. Pass Parameters to your shell script For example, if we wanna edit an existent text, and if the file doesn’t exist, the system shall create one, we can write a script named ‘’edit.sh”” as below: 1234567name=$1if [ -d /e/blog/source/_posts/$&#123;name&#125; ]then echo &quot;$&#123;name&#125; does not exist\\n&quot; hexo new $&#123;name&#125;fivim /e/blog/source/_posts/$&#123;name&#125; then: 1chmod 755 edit.sh So can we call the edit.sh as if using a built-in command. 1edit.sh &quot;FOO&quot; Convert .deb into .tar安装alien123456# 从镜像站下载alien的rpm包wget https://mirrors.aliyun.com/centos-vault/2.1/final/i386/CentOS/RPMS/alien-7.24-3.noarch.rpmrpm -ivh alien-7.24-3.noarch.rpm# 如果有rpm包安装有依赖，可以# rpm -ivh *.rpm --nodeps --force# --nodeps指忽略包依赖，--force指强制执行 使用alien1alien -r filename.deb generated","categories":[{"name":"Linux","slug":"Linux","permalink":"http://endsieg77.github.io/categories/Linux/"}],"tags":[{"name":"utilities","slug":"utilities","permalink":"http://endsieg77.github.io/tags/utilities/"},{"name":"basic","slug":"basic","permalink":"http://endsieg77.github.io/tags/basic/"}]},{"title":"Effective C++","date":"2021-01-02T18:01:15.000Z","path":"2021/01/03/Effective-C/","text":"Introduction View C++ as a federation of Languages​ In Scott Meyer’s opinions, Modern C++ supports different paradigms of programming, including C, Object-Oriented C++, Template C++(with its byproduct of C++ Template Meta Programming, short for CTMP) and STL. The Enum Hack​ e.g. 12345678class GamePlayer &#123;private: enum &#123; NumTurns = 5; &#125;; // To make &quot;NumTurns&quot; // a mark name of 5. int scores[NumTurns]; // That would be alright. ...&#125;; Overload the function with different constness​ We always neglect the fact that two member functions with different constness can be overloaded. ​ e.g. 1234567891011121314151617181920212223242526272829303132333435// a template class of Array:template&lt;class _Ty, size_t _Size&gt;class Array&#123; ... typedef _Ty&amp; reference; typedef const _Ty&amp; const_reference;public: ... const_reference operator[](const size_t&amp;) const noexcept; reference operator[](const size_t&amp;) noexcept;private: ...&#125;; // const version of operator[]:template&lt;class _Ty, size_t _Size&gt;inlinetypename Array&lt;_Ty, _Size&gt;::const_reference Array&lt;_Ty, _Size&gt;::operator[](const size_t &amp;__index) const noexcept&#123; return *(begin() + __index); &#125;// non-const version of operator[]:template&lt;class _Ty, size_t _Size&gt;inlinetypename Array&lt;_Ty, _Size&gt;::reference Array&lt;_Ty, _Size&gt;::operator[](const size_t &amp;__index) noexcept&#123; return const_cast&lt;_Ty&amp;&gt;( // cast away the constness; static_cast&lt;const Array&amp;&gt;(*this) // cast *this into a const [__index] // reference to call the ); // const version of operator[];&#125; Use mutable to change member variables at will. Assign the similar initialization tasks to member functions declared privateor delegation constructors to avoid the mechanical repetition of codes. Realize simple singleton by:1234Obj &amp;SingletonFact() &#123; static Obj object &#123;params&#125;; return object; // return the handle of object&#125; Constructor, Destructor, Assignment Forbid the unwilled operations​ Add an = delete at the end of the function to forbid the call of them.(After C++11) EBO(To Be Continued)Don’t declare function as virtual if unnecessary​ Object must contain some information to judge which version of function to be called, ​ This information is usually pointed out by a pointer called vptr(virtural table pointer) which points an array made up of function pointers, called vtbl(virtual table), which causes the expansion of the size of objects. Pure Virtual Function makes the class abstract123456class Sample &#123; ... virtual ~Sample() = 0; // Sample cannot be instantiated now.&#125;Sample::~Sample() &#123; &#125;; Never call a virtual function when the object has not been initialized​ We can memorize it by a recipe: “Virtual function is not a virtual function, when the object is under construction.” Basically, the call of virtual function in this section violates the principles of runtime polymorphism. Use Identity Test to avoid the self-assignment1234567Widget &amp;Widget::operator=(const Widget &amp;rhs) &#123; if(this == &amp;rhs) return *this; // Identity Test. delete pb; // pb is a member of Widget which points a Bitmap; pb = new Bitmap(*rhs.pb); return *this;&#125; copy-and-swap strategy may function well12345Widget &amp;Widget::operator=(const Widget &amp;rhs) &#123; Widget temp(rhs); swap(temp); return *this;&#125; Resource Management Smart Pointer下面是一个工厂函数： 1Investment *createInvestment(); 我们希望构造的Investment在超出生命周期后立马被析构。那么我们可以用只能指针来封装Investment * 。 Smart pointer uses reference count as its gist to judge if the pointer packaged shall expire. std::unique_ptr can be referred to only once. std::shared_ptr can be referred to several times. Circular Referencestd::shared_ptr should be combined with std::weak_ptr to avoid circular reference. A Sample of Circular Reference: 123456789101112131415161718192021class A&#123;public: ~A() &#123;cout&lt;&lt;&quot;A Expired&quot;&lt;&lt;endl;&#125; shared_ptr&lt;B&gt; b;&#125;;class B&#123;public: ~B() &#123;cout&lt;&lt;&quot;B Expired&quot;&lt;&lt;endl;&#125;; shared_ptr&lt;A&gt; a;&#125;;void Test()&#123; shared_ptr&lt;A&gt; pa(new A); shared_ptr&lt;B&gt; pb(new B); pa-&gt;b = pb; pb-&gt;a = pa;&#125; 调用Test()后发现A, B的析构函数均未被正常调用。 这个过程如下： pa想要被析构，但pa的引用仍然被pb所指对象所把持，导致pa无法被析构。而pb也是如此，无法被正常析构。 我们只要把其中一个shared_ptr替换成weak_ptr即可。weak_ptr不具备资源管理的能力，其只提供了一个expired()接口检测资源是否被释放。 A Class Intended for Resource ManagementTwo Critical Criterion: RAII， 获得资源后立刻放入资源管理对象。 管理对象运用析构函数确保资源被释放。","categories":[{"name":"Cpp","slug":"Cpp","permalink":"http://endsieg77.github.io/categories/Cpp/"}],"tags":[{"name":"utilities","slug":"utilities","permalink":"http://endsieg77.github.io/tags/utilities/"}]},{"title":"latex","date":"2021-01-01T18:46:36.000Z","path":"2021/01/02/latex/","text":"build a matrix \\left( \\begin{array} {ccc} 1 & 2 & 3\\\\ 4 & 5 & 6\\\\ 7 & 8 & 11 \\\\ \\end{array} \\right) integral \\int_a^bf(x)\\mathrm{d}x dot product {a}\\cdot{b} i-hat \\hat{i} limit \\lim_{x\\rightarrow+\\infty}f(x) &gt;=, &lt;= \\ge \\\\ \\le ellipsis \\dots \\\\ \\cdots brace \\left\\{ \\begin{array}{ll} , & \\hbox{;} \\\\ , & \\hbox{;} \\\\ , & \\hbox{.} \\end{array} \\right. vector \\vec{x} Something about sets \\exists \\\\ \\forall \\\\ \\in \\\\ \\notin \\\\ \\subset \\\\ \\subsetneqq \\\\ \\supset \\\\ \\supsetneqq \\\\ \\cap \\\\ \\cup \\\\ \\overline{A} \\\\ \\emptyset \\\\ \\setminus \\\\ \\mathbb{R} Because, therefore \\because\\\\\\therefore","categories":[{"name":"Latex","slug":"Latex","permalink":"http://endsieg77.github.io/categories/Latex/"}],"tags":[{"name":"utilities","slug":"utilities","permalink":"http://endsieg77.github.io/tags/utilities/"}]},{"title":"ot_fs","date":"2021-01-01T11:13:46.000Z","path":"2021/01/01/ot-fs/","text":"Every atom alongside me whispers your numinous name. My nostalgia comes out resembling the fiery flame, Soul captured as your obedient slave. I cannot distinguish the reality from dream, Wandering aimlessly as if a savannah nomad. Sounds like the most mystical thing right? Amidst it I have no where to never escape. A witch wields her wondrous wand, Appealing to me with the obscure magic. How I wish I were not that timid. How I wish I could comprehend, Her delicate heart.","categories":[{"name":"letters","slug":"letters","permalink":"http://endsieg77.github.io/categories/letters/"}],"tags":[{"name":"Poems","slug":"Poems","permalink":"http://endsieg77.github.io/tags/Poems/"}]},{"title":"Dirge_of_Hallownest","date":"2020-12-31T11:14:00.000Z","path":"2020/12/31/Dirge-of-Hallownest/","text":"In wilds beyond they speak your name with reverence(n.尊敬,崇敬) and regret, For none could tame our savage(adj.野蛮的,凶恶的) souls yet you the challenge met, Under palest watch, you taught, you changed.Base instincts were redeemed(vt.救赎), A world you gave to bug and beast as they had never dreamed. Our cherished dreams you granted and delivered more, But in dismay(n.沮丧;诧异,惊愕) you found too late our desires had no end,What cost to tame savagery(n.残暴行为-&gt;愤怒)? You gave your all and then gave more.Yet still desires lay unquenched, more dreams remained, your energies spent. Amongst it sprang a dreadful(adj.可怕的) scourge(n.灾害,祸害),that forced return our aggressive urge,and turned us back to beasts or husks(n.躯壳,外壳), Our souls consumed by light above. Within your corpse(n.尸体) can still be heard the plaintiff(n.控诉人-&gt;控诉) cries of one,Who took our pain, and loss, and dreams inside itself to… Through it’s pain we found a truth that must now be confessed(vt.承认,供认,坦白),For nothing can contain such things but perfect emptiness.","categories":[{"name":"Hollow Knight","slug":"Hollow-Knight","permalink":"http://endsieg77.github.io/categories/Hollow-Knight/"}],"tags":[{"name":"Poems","slug":"Poems","permalink":"http://endsieg77.github.io/tags/Poems/"}]},{"title":"lambda expr","date":"2020-12-31T11:13:14.000Z","path":"2020/12/31/lambda-expr/","text":"Basic GrammarIn C++, a lambda expression(Also a closure) is in a form as below:1[capture] [(parameters)] [mutable] [-&gt;return-type]&#123;statement&#125; [capture] Capture List. ‘[]’ functions as an introduction to a lambda expression;Essentially, lambda expression in C++ is functor, but it’s simpler and can be defined anywhere;The compiler judges if the following code is lambda function accoarding to the ‘[]’ introducer;The Capture List can capture the varibles in the context for lambda function to use; (parameters)Parameter List. Shares the similar rule with the ordinary function. Can be omitted if no parameterpass is required; mutablemutable identifier. Lambda functions will not change its parameters’ value, mutable can remove its constness;With the identifier, lambda functions parameter list cannot be omitted; -&gt;return-typeReturn Type. Declare the return type of function using trailing-return-type;Can be omitted if no return value is required. We can also omit it when the return type can be easily deduced by compiler; &#123;statement&#125;Function Body; More About Capture List [var]Capture var passed-by-value； [=]Capture all variables in the father block; [&amp;var] Capture var passed-by-reference; [&amp;]Capture all variables in the father block; [this]Explicitly capture “this” pointer; [x, y, , ..., &amp;]Capture all variables before ‘&amp;’ by value, and all others by reference; [&amp;x, &amp;y, ..., =]Similar to 6.; Call at once1[capture](formal_params)&#123;statement&#125;(real_params); Currying(Nesting of Lambda Expressions)1[capture](params)-&gt;return-type&#123;return [capture](params)-&gt;return-type&#123;&#125;;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"http://endsieg77.github.io/categories/Cpp/"}],"tags":[{"name":"grammatical","slug":"grammatical","permalink":"http://endsieg77.github.io/tags/grammatical/"},{"name":"basic","slug":"basic","permalink":"http://endsieg77.github.io/tags/basic/"}]},{"title":"matlab 1","date":"2020-12-31T11:13:05.000Z","path":"2020/12/31/matlab-1/","text":"%: notes%% %%: build a section. rem(): get remainder. 1234567891011switch input_numcase constant1 statement1case constant2 statement2...case constant_n statement_notherwise statement_defaultend prod(vector): yields vector[1]*…*vector[n]","categories":[{"name":"Matlab","slug":"Matlab","permalink":"http://endsieg77.github.io/categories/Matlab/"}],"tags":[{"name":"utilities","slug":"utilities","permalink":"http://endsieg77.github.io/tags/utilities/"}]},{"title":"matlab 0","date":"2020-12-31T11:12:51.000Z","path":"2020/12/31/matlab-0/","text":"Function:exp(x): e^x Commands: who: show all variableswhos: who + types +valuesclc: clear command windowclear: clear parameter tableformat [parameter] (parameter = short, long, shortE, longE, rational(rat)) Row vector&gt;&gt; a = [1 2 3 4] Column vector&gt;&gt; b = [1; 2; 3; 4] Matrix:&gt;&gt; c = [1 2 3; 4 5 6; 7 8 9] Colon Operator A = [1 2 3 ... 100] j:k =&gt; [j, j+1, j+2, ..., j+m], j+m&lt;=kj:i:k =&gt; [j, j+i, j+2i, ..., j+m*i], j+m*i&lt;=k A(i,:) = [] clear the i-th row of A arithmetic point multiplication:.* A = [a b; c d] B = [h i; j k] A .* B = [a*h b*i; c*j d*k] a an integer, a + A refers to the arithmetic thateach element of A plus a.The ^ .^ / -follow the similar rule. build some special matrixes linspace(begin, end(, step(default value 1))) eye(n): yields an n*n identity matrix. zeros(n1,n2): yields a n1*n2 zero matrix. ones(n1,n2): resembles zeros(). uses 1 instead. diag([row_vector]): yields a diagnol matrix. rand(): uniformly distributed random numbers. Matrix functions max(A): yields an row vector including themaximum num of each column of A. max(max(A)): yields the maximum num of A. min() sum() mean() resembles max() in terms of rules. sort(): sort elements of each columns by ascending order. sortrows(): sort rows with their first element by ascending order. size(): yields two numbers representing the dimensional parameter. length(): yields the multiplication of the two return value of size(). find(): e.g. A = [1 2 3; 4 5 6; 7 8 9], then find(4) = 2, find(8) = 6.","categories":[{"name":"Matlab","slug":"Matlab","permalink":"http://endsieg77.github.io/categories/Matlab/"}],"tags":[{"name":"utilities","slug":"utilities","permalink":"http://endsieg77.github.io/tags/utilities/"}]}]